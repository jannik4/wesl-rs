[
  {
    "name": "declare-global-var-private",
    "desc": "declares a global integer variable in the private address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> myVar: i32;",
    "expect": "pass"
  },
  {
    "name": "declare-global-var-invalid-address-space",
    "desc": "attempts to declare a global variable with an invalid address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<invalid> myVar: i32;",
    "expect": "fail"
  },
  {
    "name": "declare-global-let",
    "desc": "let-declarations inside functions are allowed",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn main() { let x: i32 = 5; }",
    "expect": "pass"
  },
  {
    "name": "declare-global-let-module",
    "desc": "let-declarations are not allowed at module scope",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let x: i32 = 5;",
    "expect": "fail"
  },
  {
    "name": "function-call-return-type",
    "desc": "function should return a f32 value",
    "kind": "eval",
    "code": "fn myFunc() -> f32 { return 1.0; }",
    "eval": "myFunc()",
    "result": "1.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "shader-interface-a",
    "desc": "attempts to use a reserved keyword as an identifier",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "fn case() { }",
    "expect": "fail"
  },
  {
    "name": "use-undefined-identifier",
    "desc": "references an undefined identifier",
    "kind": "eval",
    "code": "fn main() { x = 5; }",
    "eval": "x",
    "expect": "fail"
  },
  {
    "name": "const-overflow-error",
    "desc": "const-expression with overflow error",
    "kind": "eval",
    "code": "const hugeValue = 1e40f;",
    "eval": "hugeValue",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "valid-float-addition",
    "desc": "adds two floating-point numbers",
    "kind": "eval",
    "code": "",
    "eval": "1.0 + 2.0",
    "result": "3.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "builtin-function-sqrt",
    "desc": "test behavior of the built-in sqrt function",
    "kind": "eval",
    "code": "",
    "eval": "sqrt(4.0)",
    "result": "2.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "empty-program",
    "desc": "An empty WGSL program must parse successfully as a valid shader module",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "",
    "expect": "pass"
  },
  {
    "name": "invalid-reserved-word-usage",
    "desc": "Using a reserved word in place of an identifier",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "fn enable() { }",
    "expect": "fail"
  },
  {
    "name": "valid-declaration-and-assignment",
    "desc": "Declare and assign to a variable in the function address space",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn main() { var x: i32 = 2; x = 3; }",
    "expect": "pass"
  },
  {
    "name": "type-mismatch-in-assignment",
    "desc": "Assigning a mismatched type to a variable",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn main() { var x: i32 = 0; x = \"string\"; }",
    "expect": "fail"
  },
  {
    "name": "builtin-function-sqrt-test",
    "desc": "Correct use of the built-in sqrt function",
    "kind": "eval",
    "code": "",
    "eval": "sqrt(16.0)",
    "result": "4.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "runtime-division-by-zero",
    "desc": "Division by zero during runtime should result in a dynamic error",
    "kind": "eval",
    "code": "fn divide(a: f32, b: f32) -> f32 { return a / b; }",
    "eval": "divide(1.0, 0.0)",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "let-initialization-type-check",
    "desc": "let-declaration must initialize to a value of the correct type",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn main() { let y: f32 = 5.0; }",
    "expect": "pass"
  },
  {
    "name": "using-const-expr-for-loop",
    "desc": "Using const-expressions to determine loop bounds",
    "kind": "eval",
    "code": "const limit = 10; fn loop_with_const() -> i32 { var sum: i32 = 0; for (var i: i32 = 0; i < limit; i = i + 1) { sum = sum + i; } return sum; }",
    "eval": "loop_with_const()",
    "result": "45",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "invalid-pointer-type-declaration",
    "desc": "Declaring a pointer type for a non-existing address space should fail",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "fn example(p: ptr<nonexistent, i32>) {}",
    "expect": "fail"
  },
  {
    "name": "valid-texture-sampler-binding",
    "desc": "Creates a valid texture and sampler binding",
    "kind": "context",
    "code": "@group(0) @binding(0) var t: texture_2d<f32>; @group(0) @binding(1) var s: sampler;",
    "expect": "pass",
    "note": "This test checks if the context is valid with resource bindings correctly declared."
  },
  {
    "name": "declare-private-global-variable",
    "desc": "Declare a global integer variable in the private address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> myVar: i32;",
    "expect": "pass"
  },
  {
    "name": "invalid-global-variable-syntax",
    "desc": "Attempting to declare a global variable with invalid syntax",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<?> myVar: i32;",
    "expect": "fail"
  },
  {
    "name": "builtin-function-sqrt-evaluation",
    "desc": "Evaluating the built-in sqrt function with a valid input",
    "kind": "eval",
    "code": "",
    "eval": "sqrt(9.0)",
    "result": "3.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-global-let-inside-function",
    "desc": "Let-declarations are allowed inside functions",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn myFunc() { let x: i32 = 10; }",
    "expect": "pass"
  },
  {
    "name": "unallowed-let-declaration-at-module-scope",
    "desc": "Let-declarations are not allowed at module scope",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let x: i32 = 10;",
    "expect": "fail"
  },
  {
    "name": "function-with-invalid-return-type",
    "desc": "A function attempts to return a value of a type that does not match its signature",
    "kind": "eval",
    "code": "fn myFunc() -> f32 { return 1; }",
    "eval": "myFunc()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "using-undefined-variable",
    "desc": "References an undefined variable in a function",
    "kind": "eval",
    "code": "fn main() { y = 5; }",
    "eval": "y",
    "expect": "fail"
  },
  {
    "name": "const-expression-overflow",
    "desc": "Const-expression that causes overflow",
    "kind": "eval",
    "code": "const hugeValue = 1e40;",
    "eval": "hugeValue",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "correct-float-addition",
    "desc": "Adding two valid floating-point numbers",
    "kind": "eval",
    "code": "",
    "eval": "2.0 + 5.5",
    "result": "7.5",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "function-call-with-pointer",
    "desc": "Correct use of a pointer in a function call returning the modified value",
    "kind": "eval",
    "code": "fn modifyValue(p: ptr<function, i32>) { *p = 2; } fn main() -> i32 { var a: i32 = 1; modifyValue(&a); return a; }",
    "eval": "main()",
    "result": "2",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-valid-private-variable",
    "desc": "Valid declaration of a private global integer variable",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> myVar: i32;",
    "expect": "pass"
  },
  {
    "name": "invalid-variable-address-space",
    "desc": "Invalid variable declaration using an unsupported address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<nonexistent> myVar2: i32;",
    "expect": "fail"
  },
  {
    "name": "builtin-function-evaluation-sqrt",
    "desc": "Using the built-in sqrt function to evaluate a correct input",
    "kind": "eval",
    "code": "",
    "eval": "sqrt(16.0)",
    "result": "4.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "let-declaration-within-function",
    "desc": "Correct use of let declaration within a function scope",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn testFunction() { let y: f32 = 3.0; }",
    "expect": "pass"
  },
  {
    "name": "invalid-let-declaration-module-scope",
    "desc": "Attempt to use a let declaration at the module level, which is not allowed",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let globalVar: i32 = 100;",
    "expect": "fail"
  },
  {
    "name": "function-with-mismatched-return-type",
    "desc": "Function returns a mismatched type not matching its defined signature",
    "kind": "eval",
    "code": "fn inconsistentReturn() -> f32 { return 1; }",
    "eval": "inconsistentReturn()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "undefined-variable-reference",
    "desc": "Attempt to use a variable that has not been defined",
    "kind": "eval",
    "code": "fn accessUndefined() { z = 42; }",
    "eval": "z",
    "expect": "fail"
  },
  {
    "name": "constant-overflow-exceed-limit",
    "desc": "Const declaration causing an overflow beyond allowable limits",
    "kind": "eval",
    "code": "const overflowCheck = 9999999999999999999999999999999999;",
    "eval": "overflowCheck",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "valid-floating-point-addition",
    "desc": "Correct result from adding two floating point numbers",
    "kind": "eval",
    "code": "",
    "eval": "5.5 + 4.5",
    "result": "10.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "function-call-with-pointer-manipulation",
    "desc": "Successful function call that manipulates a passed pointer argument",
    "kind": "eval",
    "code": "fn modify(p: ptr<function, i32>) { *p = 42; } fn main() -> i32 { var num: i32 = 0; modify(&num); return num; }",
    "eval": "main()",
    "result": "42",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "global-variable-declaration-private",
    "desc": "Declare a global integer variable in the private address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> globalInt: i32 = 5;",
    "expect": "pass"
  },
  {
    "name": "reserved-word-invalid-identifier",
    "desc": "Using a reserved keyword 'fn' as an identifier",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let fn: i32 = 10;",
    "expect": "fail"
  },
  {
    "name": "math-builtin-cos",
    "desc": "Evaluate the cosine of a value using a builtin function",
    "kind": "eval",
    "code": "",
    "eval": "cos(0.0)",
    "result": "1.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "function-scope-let-declaration",
    "desc": "Declare and initialize a let variable within a function scope",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn myFunction() { let pi: f32 = 3.1415; }",
    "expect": "pass"
  },
  {
    "name": "module-scope-let-declaration",
    "desc": "Attempt to declare a let variable at module scope",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let moduleLet: i32 = 10;",
    "expect": "fail"
  },
  {
    "name": "function-mismatched-return",
    "desc": "Define a function that returns a value of the wrong type",
    "kind": "eval",
    "code": "fn incorrectReturn() -> f32 { return 1; }",
    "eval": "incorrectReturn()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "undefined-variable-reference",
    "desc": "Reference an undefined variable, resulting in an error",
    "kind": "eval",
    "code": "fn referenceError() { return undeclaredVar; }",
    "eval": "referenceError()",
    "expect": "fail"
  },
  {
    "name": "constant-expression-overflow",
    "desc": "Const-expression with an overflow error due to large constant",
    "kind": "eval",
    "code": "const veryLarge = 1e20;",
    "eval": "veryLarge",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "add-floating-point-numbers",
    "desc": "Add two valid floating point numbers and check result",
    "kind": "eval",
    "code": "",
    "eval": "10.5 + 20.5",
    "result": "31.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "pointer-manipulation-in-function",
    "desc": "Use a function to manipulate a pointer to a variable",
    "kind": "eval",
    "code": "fn increment(val: ptr<function, i32>) { *val += 10; } fn main() -> i32 { var i: i32 = 0; increment(&i); return i; }",
    "eval": "main()",
    "result": "10",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "private-global-variable-declaration",
    "desc": "Declare a global variable using the private keyword",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> myInt: i32 = 10;",
    "expect": "pass"
  },
  {
    "name": "incorrect-use-of-reserved-word",
    "desc": "Use of a reserved keyword 'loop' as an identifier",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let loop: f32 = 3.14;",
    "expect": "fail"
  },
  {
    "name": "evaluate-builtin-sin-function",
    "desc": "Evaluate the sine of a number using a builtin function",
    "kind": "eval",
    "code": "",
    "eval": "sin(1.5708)",
    "result": "1.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "function-let-variable-declaration",
    "desc": "Declare let variable within a function body",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn computePi() { let pi: f32 = 3.14159; }",
    "expect": "pass"
  },
  {
    "name": "invalid-module-level-let-declaration",
    "desc": "Incorrectly declare a let variable at module level",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let total: u32 = 100;",
    "expect": "fail"
  },
  {
    "name": "function-type-mismatch-return",
    "desc": "Define a function that tries to return a wrong type",
    "kind": "eval",
    "code": "fn returnIncorrect() -> f32 { return \"string\"; }",
    "eval": "returnIncorrect()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "use-before-declaration-error",
    "desc": "Referencing a variable before it is declared",
    "kind": "eval",
    "code": "fn compute() { return undeclaredVar + 5; }",
    "eval": "compute()",
    "expect": "fail"
  },
  {
    "name": "const-expression-out-of-bounds",
    "desc": "Const-expression exceeding allowable bounds",
    "kind": "eval",
    "code": "const hugeNumber = 1e50;",
    "eval": "hugeNumber",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "float-addition-precision",
    "desc": "Perform addition with floating point precision",
    "kind": "eval",
    "code": "",
    "eval": "0.1 + 0.2",
    "result": "0.3",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "function-manipulates-pointer",
    "desc": "Function manipulates a pointer to change variable",
    "kind": "eval",
    "code": "fn doubleValue(p: ptr<function, i32>) { *p *= 2; } fn main() -> i32 { var value: i32 = 10; doubleValue(&value); return value; }",
    "eval": "main()",
    "result": "20",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-private-variable",
    "desc": "Declare a global variable in the private address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> testVar: i32 = 5;",
    "expect": "pass"
  },
  {
    "name": "invalid-syntax-reserved-word",
    "desc": "Using a reserved keyword 'struct' as a variable name",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let struct: i32 = 10;",
    "expect": "fail"
  },
  {
    "name": "use-builtin-trig-function",
    "desc": "Evaluate cosine using a builtin function",
    "kind": "eval",
    "code": "",
    "eval": "cos(0.0)",
    "result": "1.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "valid-let-declaration-within-function",
    "desc": "Declare let variable within a function",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn exampleFunction() { let constant: f32 = 2.718; }",
    "expect": "pass"
  },
  {
    "name": "invalid-module-let-declaration",
    "desc": "Incorrectly declare a let variable at module scope",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let piApprox: f32 = 3.14;",
    "expect": "fail"
  },
  {
    "name": "function-return-type-mismatch",
    "desc": "Function returns type that doesn't match its declaration",
    "kind": "eval",
    "code": "fn mismatchedReturn() -> f32 { return 42; }",
    "eval": "mismatchedReturn()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "reference-undefined-variable",
    "desc": "Reference a variable that's never been declared",
    "kind": "eval",
    "code": "fn useUndefined() { return undefinedVar; }",
    "eval": "useUndefined()",
    "expect": "fail"
  },
  {
    "name": "overflow-in-const-expression",
    "desc": "Constant expression with a value too large to handle",
    "kind": "eval",
    "code": "const bigNumber = 1e60;",
    "eval": "bigNumber",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "accurate-floating-point-addition",
    "desc": "Perform accurate addition using floating point numbers",
    "kind": "eval",
    "code": "",
    "eval": "1.1 + 2.2",
    "result": "3.3",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "pointer-operation-in-function",
    "desc": "Change variable through a function manipulating its pointer",
    "kind": "eval",
    "code": "fn triple(n: ptr<function, i32>) { *n *= 3; } fn main() -> i32 { var count: i32 = 7; triple(&count); return count; }",
    "eval": "main()",
    "result": "21",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-private-variable",
    "desc": "Declare a global variable in the private address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> testVar: i32 = 5;",
    "expect": "pass"
  },
  {
    "name": "invalid-syntax-reserved-word",
    "desc": "Using a reserved keyword 'struct' as a variable name",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let struct: i32 = 10;",
    "expect": "fail"
  },
  {
    "name": "use-builtin-trig-function",
    "desc": "Evaluate cosine using a builtin function",
    "kind": "eval",
    "code": "fn calculate() -> f32 { return cos(0.0); }",
    "eval": "calculate()",
    "result": "1.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "valid-let-declaration-within-function",
    "desc": "Declare let variable within a function",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn exampleFunction() { let constant: f32 = 2.718; }",
    "expect": "pass"
  },
  {
    "name": "invalid-module-let-declaration",
    "desc": "Incorrectly declare a let variable at module scope",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let piApprox: f32 = 3.14;",
    "expect": "fail"
  },
  {
    "name": "function-return-type-mismatch",
    "desc": "Function returns type that doesn't match its declaration",
    "kind": "eval",
    "code": "fn mismatchedReturn() -> f32 { return 42; }",
    "eval": "mismatchedReturn()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "reference-undefined-variable",
    "desc": "Reference a variable that's never been declared",
    "kind": "eval",
    "code": "fn useUndefined() { return undefinedVar; }",
    "eval": "useUndefined()",
    "expect": "fail"
  },
  {
    "name": "overflow-in-const-expression",
    "desc": "Constant expression with a value too large to handle",
    "kind": "eval",
    "code": "const bigNumber = 1e60;",
    "eval": "bigNumber",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "accurate-floating-point-addition",
    "desc": "Perform accurate addition using floating point numbers",
    "kind": "eval",
    "code": "fn add() -> f32 { return 1.1 + 2.2; }",
    "eval": "add()",
    "result": "3.3",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "pointer-operation-in-function",
    "desc": "Change variable through a function manipulating its pointer",
    "kind": "eval",
    "code": "fn triple(n: ptr<function, i32>) { *n *= 3; } fn main() -> i32 { var count: i32 = 7; triple(&count); return count; }",
    "eval": "main()",
    "result": "21",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-private-var",
    "desc": "Declare a global variable in the private address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> testVar: i32 = 5;",
    "expect": "pass"
  },
  {
    "name": "reserved-word-identifier",
    "desc": "Using a reserved keyword 'fn' as a variable name",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let fn: i32 = 20;",
    "expect": "fail"
  },
  {
    "name": "cosine-builtin-function",
    "desc": "Evaluating cosine of 0 using a builtin function",
    "kind": "eval",
    "code": "fn calcCos() -> f32 { return cos(0.0); }",
    "eval": "calcCos()",
    "result": "1.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "let-declaration-in-function",
    "desc": "Declare a let variable within a function",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn getPi() { let pi: f32 = 3.14; }",
    "expect": "pass"
  },
  {
    "name": "module-let-declaration",
    "desc": "Attempt to declare a let variable at module scope",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let euler: f32 = 2.718;",
    "expect": "fail"
  },
  {
    "name": "wrong-return-type-function",
    "desc": "Function returns an incorrect type",
    "kind": "eval",
    "code": "fn wrongReturn() -> f32 { return 'error'; }",
    "eval": "wrongReturn()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "undefined-variable-error",
    "desc": "Reference an undefined variable in a function",
    "kind": "eval",
    "code": "fn showError() { return unknownVar; }",
    "eval": "showError()",
    "expect": "fail"
  },
  {
    "name": "large-const-expression",
    "desc": "Const expression with value too large for static analysis",
    "kind": "eval",
    "code": "const tooLarge = 1e50;",
    "eval": "tooLarge",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "precise-float-addition",
    "desc": "Accurate computation of the addition of floating point numbers",
    "kind": "eval",
    "code": "fn sumFloats() -> f32 { return 0.1 + 0.2; }",
    "eval": "sumFloats()",
    "result": "0.3",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "pointer-manipulation-in-function",
    "desc": "Modify a variable via function-based pointer manipulation",
    "kind": "eval",
    "code": "fn doubleValue(num: ptr<function, i32>) { *num *= 2; } fn main() -> i32 { var value: i32 = 10; doubleValue(&value); return value; }",
    "eval": "main()",
    "result": "20",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-private-integer-variable",
    "desc": "Declare a global integer variable in the private address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> myInt: i32 = 10;",
    "expect": "pass"
  },
  {
    "name": "use-reserved-word-as-identifier",
    "desc": "Attempt to use a reserved keyword 'while' as a variable name",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let while: i32 = 5;",
    "expect": "fail"
  },
  {
    "name": "evaluate-sin-builtin-function",
    "desc": "Evaluate the sine of PI/2 using a builtin function",
    "kind": "eval",
    "code": "fn calculateSin() -> f32 { return sin(1.5708); }",
    "eval": "calculateSin()",
    "result": "1.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-let-variable-in-function",
    "desc": "Declare and initialize a let variable within function scope",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn main() { let gravity: f32 = 9.81; }",
    "expect": "pass"
  },
  {
    "name": "module-scope-let-declaration-failure",
    "desc": "Declare a let variable at module scope which is not allowed",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let planck: f32 = 6.626e-34;",
    "expect": "fail"
  },
  {
    "name": "return-type-mismatch-in-function",
    "desc": "Function returning a type inconsistent with its signature",
    "kind": "eval",
    "code": "fn mismatchedReturn() -> f32 { return \"hello\"; }",
    "eval": "mismatchedReturn()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "reference-undeclared-variable-error",
    "desc": "Reference an undeclared variable within a function",
    "kind": "eval",
    "code": "fn access() { return uninitializedVar; }",
    "eval": "access()",
    "expect": "fail"
  },
  {
    "name": "const-expression-overflow-error",
    "desc": "Const expression with an oversized value produces error",
    "kind": "eval",
    "code": "const massive = 1e100;",
    "eval": "massive",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "accurate-floating-addition",
    "desc": "Correct addition result using floating point precision",
    "kind": "eval",
    "code": "fn addFloat() -> f32 { return 0.1 + 0.2; }",
    "eval": "addFloat()",
    "result": "0.3",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "function-pointer-variable",
    "desc": "Use function to double a value via pointer manipulation",
    "kind": "eval",
    "code": "fn multiplyByTwo(num: ptr<function, i32>) { *num *= 2; } fn main() -> i32 { var count: i32 = 5; multiplyByTwo(&count); return count; }",
    "eval": "main()",
    "result": "10",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-private-integer-variable",
    "desc": "Declare a global integer variable in the private address space",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "var<private> myInt: i32 = 10;",
    "expect": "pass"
  },
  {
    "name": "use-reserved-word-as-identifier",
    "desc": "Attempt to use a reserved keyword 'while' as a variable name",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let while: i32 = 5;",
    "expect": "fail"
  },
  {
    "name": "evaluate-sin-builtin-function",
    "desc": "Evaluate the sine of PI/2 using a builtin function",
    "kind": "eval",
    "code": "fn calculateSin() -> f32 { return sin(1.5708); }",
    "eval": "calculateSin()",
    "result": "1.0",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "declare-let-variable-in-function",
    "desc": "Declare and initialize a let variable within function scope",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn main() { let gravity: f32 = 9.81; }",
    "expect": "pass"
  },
  {
    "name": "module-scope-let-declaration-failure",
    "desc": "Declare a let variable at module scope which is not allowed",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "let planck: f32 = 6.626e-34;",
    "expect": "fail"
  },
  {
    "name": "return-type-mismatch-in-function",
    "desc": "Function returning a type inconsistent with its signature",
    "kind": "eval",
    "code": "fn mismatchedReturn() -> f32 { return \"hello\"; }",
    "eval": "mismatchedReturn()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "reference-undeclared-variable-error",
    "desc": "Reference an undeclared variable within a function",
    "kind": "eval",
    "code": "fn access() { return uninitializedVar; }",
    "eval": "access()",
    "expect": "fail"
  },
  {
    "name": "const-expression-overflow-error",
    "desc": "Const expression with an oversized value produces error",
    "kind": "eval",
    "code": "const massive = 1e100;",
    "eval": "massive",
    "expect": "fail",
    "stage": "const"
  },
  {
    "name": "accurate-floating-addition",
    "desc": "Correct addition result using floating point precision",
    "kind": "eval",
    "code": "fn addFloat() -> f32 { return 0.1 + 0.2; }",
    "eval": "addFloat()",
    "result": "0.3",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "function-pointer-variable",
    "desc": "Use function to double a value via pointer manipulation",
    "kind": "eval",
    "code": "fn multiplyByTwo(num: ptr<function, i32>) { *num *= 2; } fn main() -> i32 { var count: i32 = 5; multiplyByTwo(&count); return count; }",
    "eval": "main()",
    "result": "10",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "simple-loop-statement",
    "desc": "Using a basic loop statement with break condition",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn loopTest() { var count: i32 = 0; loop { if (count == 10) { break; } count = count + 1; } }",
    "expect": "pass"
  },
  {
    "name": "if-else-statement",
    "desc": "Correct use of if-else statements with varying conditions",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn conditionalTest(x: i32) { if (x > 5) { x = x - 1; } else { x = x + 1; } }",
    "expect": "pass"
  },
  {
    "name": "switch-statement-with-default",
    "desc": "Use of a switch statement with a default case",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn switchTest(value: i32) -> i32 { switch (value) { case 1: { return 10; } default: { return 0; } } }",
    "expect": "pass"
  },
  {
    "name": "array-access-verification",
    "desc": "Access elements within an array using a loop",
    "kind": "eval",
    "code": "fn arraySum(arr: array<i32, 4>) -> i32 { var sum: i32 = 0; for (var i: i32 = 0; i < 4; i = i + 1) { sum = sum + arr[i]; } return sum; }",
    "eval": "arraySum(array<i32, 4>(1, 2, 3, 4))",
    "result": "10",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "function-recursion-error",
    "desc": "Attempt to recurse a function should result in an error",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "fn recurse(x: i32) -> i32 { return recurse(x + 1); }",
    "expect": "fail"
  },
  {
    "name": "comparison-operators",
    "desc": "Use of comparison operators in conditions",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn compareOp(x: i32, y: i32) -> bool { return x <= y && x != 0; }",
    "expect": "pass"
  },
  {
    "name": "unsupported-pointer-operations",
    "desc": "Execution of unsupported pointer arithmetic",
    "kind": "syntax",
    "syntax": "expression",
    "code": "fn pointerOp(p: ptr<function, i32>) -> ptr<function, i32> { return p + 1; }",
    "expect": "fail"
  },
  {
    "name": "struct-member-access",
    "desc": "Correctly accessing and modifying struct members",
    "kind": "eval",
    "code": "struct Data { a: f32, b: i32 } fn modifyStruct(d: ptr<function, Data>) { (*d).a = 3.14; (*d).b = 10; } fn main() -> Data { var example: Data = Data(0.0, 0); modifyStruct(&example); return example; }",
    "eval": "main().a",
    "result": "3.14",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "invalid-swizzle-expression",
    "desc": "Swizzle operations mixing different components",
    "kind": "syntax",
    "syntax": "expression",
    "code": "fn swizzleTest(v: vec4<f32>) -> vec4<f32> { return v.rgba + v.wx; }",
    "expect": "fail"
  },
  {
    "name": "multiple-entry-point-declarations",
    "desc": "Declaring multiple entry points in a single module",
    "kind": "context",
    "code": "@vertex\n fn vertMain() {} @fragment\n fn fragMain() {}",
    "expect": "pass",
    "note": "Ensures multiple entry points can exist within one module."
  },
  {
    "name": "valid-continue-in-loop",
    "desc": "Using a continue statement correctly within a loop",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn loopWithContinue() { var i: i32 = 0; loop { i = i + 1; if (i < 5) { continue; } break; } }",
    "expect": "pass"
  },
  {
    "name": "const-array-declaration",
    "desc": "Declare a const array and verify access within bounds",
    "kind": "eval",
    "code": "fn accessArray() -> i32 { const values = array<i32, 3>(1, 2, 3); return values[1]; }",
    "eval": "accessArray()",
    "result": "2",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "cyclic-struct-declarations-error",
    "desc": "Using cyclic struct definitions should result in an error",
    "kind": "context",
    "code": "struct A { b: B } struct B { a: A }",
    "expect": "fail"
  },
  {
    "name": "infinite-loop-no-break",
    "desc": "An infinite loop with no break or continuation condition",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn infiniteLoop() { loop { var n: i32 = 0; } }",
    "expect": "pass"
  },
  {
    "name": "pipeline-creation-failure-test",
    "desc": "Expression overflowing during pipeline creation",
    "kind": "eval",
    "code": "override largeValue = 1e100;",
    "eval": "largeValue",
    "expect": "fail",
    "stage": "override"
  },
  {
    "name": "dynamic-error-array-out-of-bounds",
    "desc": "Accessing an element out of array bounds dynamically should be caught",
    "kind": "eval",
    "code": "fn outOfBoundsAccess() -> i32 { var arr = array<i32, 2>(10, 20); return arr[3]; }",
    "eval": "outOfBoundsAccess()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "shadow-variable-in-loop",
    "desc": "Variable shadowing within a loop should work correctly",
    "kind": "eval",
    "code": "fn shadowVar() -> i32 { var x: i32 = 1; loop { var x: i32 = 2; return x; } }",
    "eval": "shadowVar()",
    "result": "2",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "overlapping-separate-variable-scopes",
    "desc": "Check for separate scopes and variable hiding",
    "kind": "eval",
    "code": "fn scopeTest() -> i32 { var a: i32 = 3; { var a: i32 = 5; } return a; }",
    "eval": "scopeTest()",
    "result": "3",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "multi-stage-derivative-operation",
    "desc": "Evaluating derivatives using multiple stages requires uniformity",
    "kind": "context",
    "code": "@fragment\n fn useDerivative(@builtin(position) pos : vec4<f32>) { let _ = dpdx(pos.x); }",
    "expect": "fail",
    "note": "Derivatives must be in uniform control flow"
  },
  {
    "name": "valid-shader-io-invariants",
    "desc": "Check inter-stage inputs and outputs for valid invariant declaration",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "@vertex fn vertMain() -> @location(0) @invariant vec4<f32> { return vec4<f32>(1.0); }",
    "expect": "pass"
  },
  {
    "name": "valid-loop-with-continue",
    "desc": "Use of continue statement correctly in a while loop",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn loopWithContinue() { var i: i32 = 0; while (i < 10) { i = i + 1; if (i % 2 == 0) { continue; } } }",
    "expect": "pass"
  },
  {
    "name": "const-array-access",
    "desc": "Accessing a const array element and verifying result",
    "kind": "eval",
    "code": "fn retrieveValue() -> i32 { const nums = array<i32, 4>(0, 1, 4, 9); return nums[2]; }",
    "eval": "retrieveValue()",
    "result": "4",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "cyclic-struct-definition",
    "desc": "Cyclic struct declarations leading to an error",
    "kind": "context",
    "code": "struct Node { next: Node; }",
    "expect": "fail",
    "note": "Cyclic dependencies in structs are not allowed"
  },
  {
    "name": "infinite-loop-no-escape",
    "desc": "Infinite loop without a break or escape condition",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn infinite() { loop { } }",
    "expect": "pass"
  },
  {
    "name": "override-expression-overflow-error",
    "desc": "Overflow during pipeline creation with override expressions",
    "kind": "eval",
    "code": "override threshold = 1e309;",
    "eval": "threshold",
    "expect": "fail",
    "stage": "override"
  },
  {
    "name": "dynamic-array-out-of-bounds",
    "desc": "Dynamic access beyond array boundaries causing error",
    "kind": "eval",
    "code": "fn accessBeyond() -> i32 { var smallArray = array<i32, 3>(1,2,3); return smallArray[4]; }",
    "eval": "accessBeyond()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "variable-shadowing-in-near-scope",
    "desc": "Correct behavior of variable shadowing within block scopes",
    "kind": "eval",
    "code": "fn shadowCheck() -> i32 { var y: i32 = 5; { var y: i32 = 10; } return y; }",
    "eval": "shadowCheck()",
    "result": "5",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "separate-variable-scopes",
    "desc": "Ensure separate scopes lead to correct final variable values",
    "kind": "eval",
    "code": "fn scopeSeparation() -> i32 { var outer: i32 = 2; { var inner: i32 = 10; outer = inner; } return outer; }",
    "eval": "scopeSeparation()",
    "result": "10",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "derivative-operation-in-fragment-shader",
    "desc": "Derivative operations in fragments need uniform control flow",
    "kind": "context",
    "code": "@fragment fn calculateDerivative(@builtin(position) pos : vec4<f32>) { if (pos.x > 1.0) { _ = dpdy(pos.y); } }",
    "expect": "fail",
    "note": "Derivatives in non-uniform flow result in compile errors"
  },
  {
    "name": "vertex-shader-with-invariant-output",
    "desc": "Check correct invariant specification for vertex output",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "@vertex fn vertexMain() -> @location(0) @invariant vec4<f32> { return vec4<f32>(0.5); }",
    "expect": "pass"
  },
  {
    "name": "correct-loop-with-continue",
    "desc": "Testing continue statement within a loop",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn testContinue() { var i: i32 = 0; loop { i = i + 2; if (i == 10) { break; } } }",
    "expect": "pass"
  },
  {
    "name": "const-array-access-verification",
    "desc": "Verifying access to a specific element in a constant array",
    "kind": "eval",
    "code": "fn accessElement() -> i32 { const arrayConst = array<i32, 5>(1, 3, 5, 7, 9); return arrayConst[3]; }",
    "eval": "accessElement()",
    "result": "7",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "cyclic-struct-declaration-error",
    "desc": "Cyclic dependency in struct declarations producing an error",
    "kind": "context",
    "code": "struct A { b: B; } struct B { a: A; }",
    "expect": "fail",
    "note": "Cyclic struct declarations should not compile"
  },
  {
    "name": "endless-loop",
    "desc": "A simple infinite loop with no termination logic",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn runEndless() { loop { } }",
    "expect": "pass"
  },
  {
    "name": "overflow-in-override-expression",
    "desc": "Overflow during pipeline creation with an override expression",
    "kind": "eval",
    "code": "override sizeLimit = 1e308;",
    "eval": "sizeLimit",
    "expect": "fail",
    "stage": "override"
  },
  {
    "name": "runtime-array-index-out-of-bounds",
    "desc": "An access to an array using an out-of-bounds index",
    "kind": "eval",
    "code": "fn fetchOutOfBounds() -> i32 { var nums = array<i32, 2>(4, 8); return nums[2]; }",
    "eval": "fetchOutOfBounds()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "variable-shadowing-within-loop",
    "desc": "Testing shadowing of a variable within a loop scope",
    "kind": "eval",
    "code": "fn shadowInLoop() -> i32 { var x: i32 = 3; loop { var x: i32 = 6; return x; } }",
    "eval": "shadowInLoop()",
    "result": "6",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "validate-variable-shadowing",
    "desc": "Ensuring correct shadowing and value visibility in scopes",
    "kind": "eval",
    "code": "fn validateShadowing() -> i32 { var outer: i32 = 5; { var outer: i32 = 7; } return outer; }",
    "eval": "validateShadowing()",
    "result": "5",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "use-of-derivatives-vertex-shader",
    "desc": "Using derivatives in vertex shader requires uniform control flow",
    "kind": "context",
    "code": "@vertex fn testDerivatives(@builtin(position) pos: vec4<f32>) { let _ = dpdx(pos.x); }",
    "expect": "fail",
    "note": "Derivatives called in vertex shader can cause non-uniform issues"
  },
  {
    "name": "vertex-output-invariant",
    "desc": "Assertion on vertex shader output with invariant attribute",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "@vertex fn outputInvariant() -> @location(0) @invariant vec4<f32> { return vec4<f32>(1.0); }",
    "expect": "pass"
  },
  {
    "name": "nested-loop-multiple-continue",
    "desc": "Nested loops with correct use of continue",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn nestedLoops() { for (var i: i32 = 0; i < 5; i = i + 1) { for (var j: i32 = 0; j < 3; j = j + 1) { if (j == 1) { continue; } } } }",
    "expect": "pass"
  },
  {
    "name": "access-fixed-array",
    "desc": "Access to an element in a fixed-size array",
    "kind": "eval",
    "code": "fn getElement() -> f32 { const numbers = array<f32, 4>(1.1, 2.2, 3.3, 4.4); return numbers[2]; }",
    "eval": "getElement()",
    "result": "3.3",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "deep-cyclic-struct-error",
    "desc": "Deep cycle in struct definitions should trigger error",
    "kind": "context",
    "code": "struct X { y: Y; } struct Y { z: Z; } struct Z { x: X; }",
    "expect": "fail",
    "note": "Ensure recursive struct definitions are caught"
  },
  {
    "name": "non-terminating-loop",
    "desc": "Loop without explicit termination condition",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn nonTerminatingLoop() { loop { } }",
    "expect": "pass"
  },
  {
    "name": "override-expression-value-limit",
    "desc": "Value limitation should capture large override expressions",
    "kind": "eval",
    "code": "override maxSize = 1e100;",
    "eval": "maxSize",
    "expect": "fail",
    "stage": "override"
  },
  {
    "name": "access-outside-array-bounds",
    "desc": "Array access with index exceeding declared bounds",
    "kind": "eval",
    "code": "fn illegalAccess() -> i32 { var data = array<i32, 5>(0, 1, 2, 3, 4); return data[5]; }",
    "eval": "illegalAccess()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "variable-redeclaration-shadowing",
    "desc": "Redefining variable in inner scope again should shadow",
    "kind": "eval",
    "code": "fn redeclareVar() -> i32 { var n: i32 = 2; { var n: i32 = 5; } return n; }",
    "eval": "redeclareVar()",
    "result": "2",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "scope-separation-in-function",
    "desc": "Ensure correct variable scope separation in a function",
    "kind": "eval",
    "code": "fn scopeCheck() -> i32 { var main: i32 = 8; { var main: i32 = 11; main = main + 1; } return main; }",
    "eval": "scopeCheck()",
    "result": "8",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "incorrect-derivative-usage",
    "desc": "Incorrectly using derivative function leading to issues",
    "kind": "context",
    "code": "@fragment fn incorrectDerivative(@builtin(sample_index) sample: u32) { let gradient = dpdy(sample); }",
    "expect": "fail",
    "note": "Derivatives must be in compatible control flow"
  },
  {
    "name": "shader-output-with-invariant",
    "desc": "Testing shader output with invariant attribute applied",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "@fragment fn outInvariant() -> @location(0) @invariant vec4<f32> { return vec4<f32>(0.5); }",
    "expect": "pass"
  },
  {
    "name": "nested-loop-continue-check",
    "desc": "Check the use of continue in nested loops works properly",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn testNestedLoops() { for (var i: i32 = 0; i < 5; i = i + 1) { for (var j: i32 = 0; j < 3; j = j + 1) { if (j == 2) { continue; } } } }",
    "expect": "pass"
  },
  {
    "name": "verify-const-array-access",
    "desc": "Verify that accessing elements in a const array works correctly",
    "kind": "eval",
    "code": "fn exampleArrayAccess() -> i32 { const values = array<i32, 6>(10, 20, 30, 40, 50, 60); return values[4]; }",
    "eval": "exampleArrayAccess()",
    "result": "50",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "structs-cyclic-error",
    "desc": "Ensure cyclic struct definitions generate an error",
    "kind": "context",
    "code": "struct Person { partner: Person; }",
    "expect": "fail",
    "note": "Cyclic struct references are not permitted"
  },
  {
    "name": "infinite-loop-check",
    "desc": "Check behavior of a loop with no break or termination",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn checkInfiniteLoop() { loop { } }",
    "expect": "pass"
  },
  {
    "name": "excessive-override-value",
    "desc": "Check if excessive value in override expression triggers error",
    "kind": "eval",
    "code": "override overlyLarge = 1e310;",
    "eval": "overlyLarge",
    "expect": "fail",
    "stage": "override"
  },
  {
    "name": "exceed-array-bounds-access",
    "desc": "Exceeding array bounds should be caught at runtime",
    "kind": "eval",
    "code": "fn getIllegalIndex() -> i32 { var numbers = array<i32, 4>(7, 14, 21, 28); return numbers[6]; }",
    "eval": "getIllegalIndex()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "shadow-variable-redeclaration",
    "desc": "Declaring a variable with the same name in a nested scope",
    "kind": "eval",
    "code": "fn variableScopeTest() -> i32 { var value: i32 = 15; { var value: i32 = 25; } return value; }",
    "eval": "variableScopeTest()",
    "result": "15",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "check-variable-scope-separation",
    "desc": "Proper handling of separated variable scopes",
    "kind": "eval",
    "code": "fn nestedScopeCheck() -> i32 { var mainValue: i32 = 12; { var mainValue: i32 = 30; mainValue = mainValue * 2; } return mainValue; }",
    "eval": "nestedScopeCheck()",
    "result": "12",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "use-derivative-improperly",
    "desc": "Improper use of derivatives within non-standard control",
    "kind": "context",
    "code": "@fragment fn improperDerivative(@builtin(position) pos: vec4<f32>) { if (pos.w > 1.0) { let rate = dpdx(pos.x); } }",
    "expect": "fail",
    "note": "Derivate operations need uniform flow context"
  },
  {
    "name": "verify-invariant-in-output",
    "desc": "Ensure that use of invariant in shader output is correct",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "@vertex fn invariantTestOutput() -> @location(1) @invariant vec4<f32> { return vec4<f32>(0.1, 0.2, 0.3, 0.4); }",
    "expect": "pass"
  },
  {
    "name": "nested-loop-continue-valid",
    "desc": "Ensure proper handling of continue in nested loops",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn validateNestedLoops() { var i: i32 = 0; loop { var j: i32 = 0; loop { j = j + 1; if (j == 3) { continue; } } i = i + 1; if (i == 5) { break; } } }",
    "expect": "pass"
  },
  {
    "name": "verify-array-constant-access",
    "desc": "Accessing correct element from a constant array",
    "kind": "eval",
    "code": "fn accessConstArray() -> i32 { const sequence = array<i32, 5>(12, 24, 36, 48, 60); return sequence[3]; }",
    "eval": "accessConstArray()",
    "result": "48",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "cyclic-structure-definition-error",
    "desc": "Cyclic struct definition should trigger a syntax error",
    "kind": "context",
    "code": "struct CycleNode { next: CycleNode; }",
    "expect": "fail",
    "note": "Structs must not contain themselves directly or indirectly"
  },
  {
    "name": "unconditional-loop-behavior",
    "desc": "Testing the behavior of an unconditional infinite loop",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn infiniteRun() { while (true) { } }",
    "expect": "pass"
  },
  {
    "name": "overflow-detection-override",
    "desc": "Detect overflow in large override-expression values",
    "kind": "eval",
    "code": "override maxDepth = 1e400;",
    "eval": "maxDepth",
    "expect": "fail",
    "stage": "override"
  },
  {
    "name": "array-index-out-of-bounds-error",
    "desc": "Check runtime error for out-of-bounds array access",
    "kind": "eval",
    "code": "fn unsafeArrayAccess() -> i32 { var data = array<i32, 3>(5, 10, 15); return data[4]; }",
    "eval": "unsafeArrayAccess()",
    "expect": "fail",
    "stage": "runtime"
  },
  {
    "name": "variable-shadowing-valid",
    "desc": "Test shadowing of variables within nested blocks",
    "kind": "eval",
    "code": "fn shadowingTest() -> i32 { var score: i32 = 100; if (true) { var score: i32 = 50; } return score; }",
    "eval": "shadowingTest()",
    "result": "100",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "scope-separation-verification",
    "desc": "Validate separate scope processing of same-named variables",
    "kind": "eval",
    "code": "fn sameNameDifferentScope() -> i32 { var level: i32 = 8; { var level: i32 = 16; level = level + 8; } return level; }",
    "eval": "sameNameDifferentScope()",
    "result": "8",
    "expect": "pass",
    "stage": "runtime"
  },
  {
    "name": "unfit-derivative-use-error",
    "desc": "Error condition when derivatives used inappropriately",
    "kind": "context",
    "code": "@fragment fn derivativeIssue(@builtin(position) pos: vec4<f32>) { if (pos.y != pos.z) { let slope = dpdy(pos.x); } }",
    "expect": "fail",
    "note": "Derivatives must be called within a consistent control flow"
  },
  {
    "name": "output-check-with-invariant",
    "desc": "Ensure shader output maintains correct invariant usage",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "@fragment fn assertInvariantOutput() -> @location(0) @invariant vec4<f32> { return vec4<f32>(0.8, 0.5, 0.2, 1.0); }",
    "expect": "pass"
  },
  {
    "name": "infinite-recursion-detection",
    "desc": "Ensure infinite recursion does not cause issues during static analysis",
    "kind": "context",
    "code": "fn recurse(in: i32) -> i32 { return recurse(in + 1); }",
    "expect": "fail",
    "note": "Recursion is not allowed and should be caught by static analysis."
  },
  {
    "name": "swizzle-assignment-ambiguity",
    "desc": "Attempt to assign to mixed swizzle components should generate an error",
    "kind": "syntax",
    "syntax": "expression",
    "code": "fn swizzleAssignmentTest(v: vec4<f32>) { v.rg = vec2<f32>(1.0, 2.0); v.r = 0.5; }",
    "expect": "fail",
    "note": "WGSL does not allow modifying components of a swizzle separately."
  },
  {
    "name": "implicit-vector-cast-edge-case",
    "desc": "Implicit cast between vectors of compatible types with slight differences",
    "kind": "eval",
    "code": "fn vectorCast() -> vec4<f32> { let a: vec4<i32> = vec4<i32>(1, 2, 3, 4); return a; }",
    "eval": "vectorCast()",
    "expect": "fail",
    "note": "WGSL requires explicit casts even for seemingly compatible types."
  },
  {
    "name": "outer-inner-shadowing-edge-case",
    "desc": "Test shadowing in nested structures within the same function scope",
    "kind": "eval",
    "code": "fn shadowOverlap() -> i32 { var x: i32 = 3; { var inner: struct { x: i32; }; { let inner = inner(x: 4); return inner.x; } } return x; }",
    "eval": "shadowOverlap()",
    "result": "4",
    "expect": "pass",
    "note": "Verify nested scoping does not disrupt outer access unexpectedly."
  },
  {
    "name": "multi-stage-overflow-constant",
    "desc": "Handling of large constants between shader stages causing overflow",
    "kind": "eval",
    "code": "const bigVal: i32 = 2147483647; fn multiStage() -> i32 { return bigVal + 1; }",
    "eval": "multiStage()",
    "result": "-2147483648",
    "expect": "pass",
    "note": "Overflow in WGSL uses two's complement wrapping."
  },
  {
    "name": "array-reference-reassignment",
    "desc": "Verify behavior when reassigning a reference to an array element",
    "kind": "eval",
    "code": "fn arrayReferenceTest() -> i32 { var nums = array<i32, 4>(0, 10, 20, 30); var ref = &nums[1]; *ref = 15; return nums[1]; }",
    "eval": "arrayReferenceTest()",
    "result": "15",
    "expect": "pass",
    "note": "Array elements should update through their references correctly."
  },
  {
    "name": "condition-dependent-derivative",
    "desc": "Derivative operation called conditionally on a varying execution path",
    "kind": "context",
    "code": "@fragment fn conditionalDerivative(@builtin(position) pos: vec4<f32>) { let check = pos.x > 0.0 ? dpdx(pos.y) : dpdy(pos.z); }",
    "expect": "fail",
    "note": "Derivative computations require consistent uniform control flow."
  },
  {
    "name": "vector-matrix-inference-ambiguity",
    "desc": "Confusing behavior when inferring types between vectors to matrices",
    "kind": "eval",
    "code": "fn inferType() -> mat3x3<f32> { let v: vec3<f32> = vec3<f32>(1.0, 2.0, 3.0); return mat3x3<f32>(v); }",
    "eval": "inferType()",
    "expect": "fail",
    "note": "WGSL demands explicit conversions for composites, vectors to matrices."
  },
  {
    "name": "cross-stage-interface-integrity",
    "desc": "Checking integrity and coherence of cross-stage interfaces",
    "kind": "context",
    "code": "@vertex fn vertOut() -> @location(0) vec4<f32> { return vec4<f32>(0.0); } @fragment fn fragIn(@location(0) color: vec4<f32>) {}",
    "expect": "pass",
    "note": "Ensures the connection between shader stages remains consistent."
  },
  {
    "name": "valid-stroage-buffer-operation",
    "desc": "Complex storage buffer operations involving atomic builtins",
    "kind": "eval",
    "code": "@group(0) @binding(0) var<storage, read_write> atomicVar: atomic<i32>; fn performAtomic() -> i32 { atomicExchange(&atomicVar, 1); return atomicLoad(&atomicVar); }",
    "eval": "performAtomic()",
    "result": "1",
    "expect": "pass",
    "note": "Checking for correct operation and updates of storage buffer atomic operations."
  },
  {
    "name": "self-referential-struct-error",
    "desc": "Test for self-referential struct leading to a likely infinite loop",
    "kind": "context",
    "code": "struct Node { next: Node; }",
    "expect": "fail",
    "note": "WGSL should not support self-referential structs as it leads to recursion."
  },
  {
    "name": "texture-dimension-mismatch",
    "desc": "Mismatch in expected texture dimension in the texture sample function",
    "kind": "context",
    "code": "@group(0) @binding(0) var texture: texture_2d_array<u32>; fn samplerUsage() { var mySampler: sampler; let _ = textureSample(texture, mySampler, vec2<f32>(0.5, 0.5)); }",
    "expect": "fail",
    "note": "texture_2d_array should not work with textureSample without specifying a correct texture dimension."
  },
  {
    "name": "nested-conditional-redundancy",
    "desc": "Complex redundant conditions with shadowing inside nested blocks",
    "kind": "eval",
    "code": "fn nestedRedundancy() -> i32 { var level: i32 = 1; if (level > 0) { var level = 2; if (level < 3) { return 42; } } return 24; }",
    "eval": "nestedRedundancy()",
    "result": "42",
    "expect": "pass",
    "note": "Ensure scoping and redundant checks do not merge unexpectedly."
  },
  {
    "name": "swizzle-on-const-scalar",
    "desc": "Attempt to apply a swizzle on a constant scalar expression",
    "kind": "syntax",
    "syntax": "expression",
    "code": "let x = 1.0; let y = x.zz; // Invalid swizzle on scalar",
    "expect": "fail"
  },
  {
    "name": "ambiguous-sampling-based-on-condition",
    "desc": "Derivatives potentially mishandled in conditionally sampled operations",
    "kind": "context",
    "code": "@fragment fn derivativeInCondition(@builtin(position) pos : vec4<f32>) { let computed = pos.x > 1.0 ? textureSample(sampler, pos.xy) : 1.0; }",
    "expect": "fail",
    "note": "Derivatives expect to be calculated in a uniform context but sampling occurs conditionally."
  },
  {
    "name": "float-int-conversion-edge",
    "desc": "Edge case by converting a large float to an integer without cast",
    "kind": "eval",
    "code": "fn convertToInt(f: f32) -> i32 { return f; } // Implicit conversion isn't allowed",
    "eval": "convertToInt(999999.0)",
    "expect": "fail",
    "note": "WGSL demands explicit casts between floating and integer types."
  },
  {
    "name": "function-return-idiosyncratic",
    "desc": "Function with inline control flow impacting what is returned",
    "kind": "eval",
    "code": "fn returnControlFlow(input: i32) -> i32 { return if(input > 5) { 5 } else { 10; }; }",
    "eval": "returnControlFlow(3)",
    "result": "10",
    "expect": "pass",
    "note": "Testing complex inline control flow affecting function return values"
  },
  {
    "name": "aliasing-in-storage-buffer",
    "desc": "Alias and incorrectly access values in the same storage buffer",
    "kind": "context",
    "code": "@group(0) @binding(0) var<storage, read_write> data: array<i32, 4>; fn aliasAndAccess() { let ptr1: ptr<storage, i32> = &data[0]; let ptr2: ptr<storage, i32> = &data[1]; *ptr1 = *ptr2; }",
    "expect": "pass",
    "note": "Check if aliasing issues cause undefined or specific effects via storage buffer access"
  },
  {
    "name": "floating-point-underflow-check",
    "desc": "Handling underflow of floating point calculations in WGSL",
    "kind": "eval",
    "code": "fn checkUnderflow() -> f32 { return 1.0e-40 * 1.0e-40; }",
    "eval": "checkUnderflow()",
    "result": "0.0",
    "expect": "pass",
    "note": "Underflow should result in values close to zero according to spec."
  },
  {
    "name": "large-const-vector-definition",
    "desc": "Define a large constant that exceeds typical vector size limits",
    "kind": "eval",
    "code": "const largeVec = array<f32, 1024>(0.0); fn accessLargeVector() -> f32 { return largeVec[512]; }",
    "eval": "accessLargeVector()",
    "result": "0.0",
    "expect": "pass",
    "note": "This test checks if WGSL allows large constant vectors inside shader scopes."
  },
  {
    "name": "recursion-stack-overflow",
    "desc": "Detect stack overflow potential through unchecked recursion",
    "kind": "context",
    "code": "fn overflowTest(n: i32) -> i32 { if (n == 0) { return 0; } else { return overflowTest(n - 1); } }",
    "expect": "fail",
    "note": "Recursion is not allowed in WGSL, as it could lead to stack overflow."
  },
  {
    "name": "return-invariance-consistency",
    "desc": "Return value with invariant causing inconsistency across executions",
    "kind": "context",
    "code": "@vertex fn vertexShader() -> @location(1) @invariant vec4<f32> { var data: vec4<f32>; if (true) { data = vec4<f32>(1.0); } return data; }",
    "expect": "pass",
    "note": "Ensures invariant return values maintain consistent results across executions."
  },
  {
    "name": "implicit-type-coercion-mismatch",
    "desc": "Implicit type conversion mismatch in composite types",
    "kind": "syntax",
    "syntax": "statement",
    "code": "fn implicitConversion() { let mixed: vec2<f32> = vec2<f32>(1, 2.0); }",
    "expect": "fail",
    "note": "WGSL requires explicit casts for integer to floating-point conversion."
  },
  {
    "name": "redundant-let-initialization",
    "desc": "Redundant initialization in let statements causing hidden errors",
    "kind": "eval",
    "code": "fn redundantLet() -> i32 { let x: i32 = 5 + 5 == 10; return x; }",
    "eval": "redundantLet()",
    "result": "1",
    "expect": "pass",
    "note": "Confirms boolean evaluation and initialization is handled correctly."
  },
  {
    "name": "dynamic-memory-overwrite",
    "desc": "Dynamic overwriting of buffer content ensures memory safety",
    "kind": "context",
    "code": "@group(0) @binding(1) var<storage, read_write> buffer: array<i32>; fn modifyBuffer() { buffer[0] = 42; }",
    "expect": "pass",
    "note": "Ensures correct handling of dynamic overwrites in storage buffers."
  },
  {
    "name": "matrix-component-indexing",
    "desc": "Edge case of accessing matrix components through indirect indexing",
    "kind": "eval",
    "code": "fn cellAccess(matrix: mat4x4<f32>, i: i32) -> f32 { return matrix[i][i]; }",
    "eval": "cellAccess(mat4x4<f32>(), 1)",
    "expect": "fail",
    "note": "WGSL enforces valid matrix indexing with known static indices."
  },
  {
    "name": "zigzag-control-flow-uniformity",
    "desc": "Uniform control flow checks between complex branching paths",
    "kind": "context",
    "code": "@fragment fn pathComplexity(@builtin(sample_index) index: i32) { if (index < 5) { for (var i: i32 = 0; i < index; i = i + 1) { } } else { } storageBarrier(); }",
    "expect": "fail",
    "note": "Uniform control flow within shader paths is critical for synchronization functions."
  },
  {
    "name": "shadowed-override-value",
    "desc": "Edge case of override constants being shadowed by function variables",
    "kind": "context",
    "code": "override connection: i32 = 1024; fn shadowOverride() { let connection: i32 = 2048; }",
    "expect": "pass",
    "note": "Override variables are separate from function-scoped variables and should be managed independently."
  },
  {
    "name": "cross-invocation-vectorizing",
    "desc": "Ensuring correct behavior of batched operations across invocations",
    "kind": "context",
    "code": "@compute @workgroup_size(1) fn vectorizeOps(inputs: array<vec4<f32>, 64>) -> f32 { var sum: f32 = 0.0; for (var i: i32 = 0; i < 64; i = i + 1) { sum = sum + inputs[i].x + inputs[i].y + inputs[i].z + inputs[i].w; } return sum; }",
    "expect": "pass",
    "note": "Verify operations are correctly vectorized and executed across multiple invocations."
  },
  {
    "name": "conditional-sampler-usage",
    "desc": "Sampler usage conditionally resulting in undefined behavior",
    "kind": "context",
    "code": "@group(0) @binding(0) var samp: sampler; @fragment fn conditionalSampler(@builtin(position) pos: vec2<f32>) { if (pos.x < 0.5) { return; } textureSample(); }",
    "expect": "fail",
    "note": "Samplers should not be used in ambiguous conditional contexts to avoid undefined behavior."
  },
  {
    "name": "recursive-const-declaration",
    "desc": "Detect issues with recursive constant declarations leading to cyclic dependencies",
    "kind": "context",
    "code": "const a: i32 = b + 1; const b: i32 = a + 1;",
    "expect": "fail",
    "note": "Const declarations cannot alude to cyclic dependencies and should fail static analysis."
  },
  {
    "name": "multi-stage-uniformity",
    "desc": "Maintaining uniformity in multi-stage shader passes with complex control flow",
    "kind": "context",
    "code": "@compute @workgroup_size(64) fn stage1(@builtin(global_invocation_id) id : vec3<u32>) { if (id.x % 2 == 0) { workgroupBarrier(); } }",
    "expect": "fail",
    "note": "Ensure that workgroup barriers must be within a uniform control path across shader stages."
  },
  {
    "name": "mixed-bindgroup-stages",
    "desc": "Ensuring integrity when using bindgroups across varying shader stages",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "@group(0) @binding(1) var<uniform> globalUniforms: array<f32>; @vertex fn vertProcess() { let value = globalUniforms[0]; } @fragment fn fragProcess() { let value = globalUniforms[1]; }",
    "expect": "pass",
    "note": "Bindings should correctly map across uniform references in multiple shader stages."
  },
  {
    "name": "invariant-non-consistency",
    "desc": "Handling invariants for outputs results in non-determinate behavior across similar contexts",
    "kind": "context",
    "code": "@vertex fn varyingValues() -> @invariant vec4<f32> { var color: vec4<f32> = vec4(0.0); if (false) { color.x = 1.0; } return color; }",
    "expect": "fail",
    "note": "Invariants must logically imply consistent behavior, otherwise cause inconsistencies or undefined states."
  },
  {
    "name": "poly-struct-instance-shadowing",
    "desc": "Struct instances should prevent shadowing within same lexical block",
    "kind": "syntax",
    "syntax": "declaration",
    "code": "struct C { v: f32; } fn containerFunction() { let instance: C = C(1.0); let instance: C = C(2.0); }",
    "expect": "fail",
    "note": "Same-named struct instances are not allowed to coexist in the same scope otherwise cause shadowing issues."
  },
  {
    "name": "arbitrary-large-override-guard",
    "desc": "Prevention of extremely large values in override declarations",
    "kind": "eval",
    "code": "override largeNumber: f32 = 3.4e38;",
    "eval": "largeNumber",
    "expect": "fail",
    "note": "Excessively large values in GPU-specific declarations should be guarded against for resource consistency."
  },
  {
    "name": "simultaneous-binding-resolution",
    "desc": "Simultaneously resolving bindings across multi-interface interactions",
    "kind": "context",
    "code": "@group(1) @binding(0) var<storage, read> readBuffer: array<i32, 64>; @group(1) @binding(0) var<storage, write> writeBuffer: array<i32, 64>; fn multiInteract() { readBuffer[0] = writeBuffer[0]; }",
    "expect": "fail",
    "note": "Binding the same resource for both reading and writing causes an overlap in access permissions."
  },
  {
    "name": "loop-unrolling-uniform-control",
    "desc": "Testing loop unrolling consistency with non-deterministic break conditions",
    "kind": "context",
    "code": "fn unrollTest() { for (var i: i32 = 0; i < 10; i = i + 1) { if (false) { break; } } workgroupBarrier(); }",
    "expect": "fail",
    "note": "Collapses loops between shader execution and must ensure consistent control flow."
  },
  {
    "name": "derivative-inter-stitching",
    "desc": "Ensuring derivatives retain continuity between segmentations of control paths",
    "kind": "context",
    "code": "@fragment fn fragmentContinuation(@builtin(position) p: vec4<f32>) { let d: f32 = dpdx(p.x); }",
    "expect": "pass",
    "note": "Derivatives trajectories should logically map with execution consistency, ensuring without breaks."
  },
  {
    "name": "sampler-filter-interaction",
    "desc": "Verifying the impact of filter and sampler interactions with boundary conditions",
    "kind": "eval",
    "code": "@group(0) @binding(0) var texSampler: sampler; @group(0) @binding(1) var tex: texture_2d<f32>; fn sampleTest() -> vec4<f32> { return textureSample(tex, texSampler, vec2<f32>(1.0, 1.0)); }",
    "eval": "sampleTest()",
    "expect": "pass",
    "note": "Texture and sampler must interact correctly ensuring no surprises when used around extrapolating boundary values."
  }
]