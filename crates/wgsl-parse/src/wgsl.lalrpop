use std::str::FromStr;
use crate::{error::ParseError, lexer::Token};
use crate::syntax::*;
use crate::parser_support::*;

// this grammar follows closely the wgsl spec.
// follwing the spec at this date: https://www.w3.org/TR/2024/WD-WGSL-20240731/

grammar;

extern {
    type Location = usize;
    type Error = (usize, ParseError, usize);
    enum Token {
        // syntactic tokens
        // https://www.w3.org/TR/WGSL/#syntactic-tokens
        "&" => Token::SymAnd,
        "&&" => Token::SymAndAnd,
        "->" => Token::SymArrow,
        "@" => Token::SymAttr,
        "/" => Token::SymForwardSlash,
        "!" => Token::SymBang,
        "[" => Token::SymBracketLeft,
        "]" => Token::SymBracketRight,
        "{" => Token::SymBraceLeft,
        "}" => Token::SymBraceRight,
        ":" => Token::SymColon,
        "," => Token::SymComma,
        "=" => Token::SymEqual,
        "==" => Token::SymEqualEqual,
        "!=" => Token::SymNotEqual,
        ">" => Token::SymGreaterThan,
        ">=" => Token::SymGreaterThanEqual,
        ">>" => Token::SymShiftRight,
        "<" => Token::SymLessThan,
        "<=" => Token::SymLessThanEqual,
        "<<" => Token::SymShiftLeft,
        "%" => Token::SymModulo,
        "-" => Token::SymMinus,
        "--" => Token::SymMinusMinus,
        "." => Token::SymPeriod,
        "+" => Token::SymPlus,
        "++" => Token::SymPlusPlus,
        "|" => Token::SymOr,
        "||" => Token::SymOrOr,
        "(" => Token::SymParenLeft,
        ")" => Token::SymParenRight,
        ";" => Token::SymSemicolon,
        "*" => Token::SymStar,
        "~" => Token::SymTilde,
        "_" => Token::SymUnderscore,
        "^" => Token::SymXor,
        "+=" => Token::SymPlusEqual,
        "-=" => Token::SymMinusEqual,
        "*=" => Token::SymTimesEqual,
        "/=" => Token::SymDivisionEqual,
        "%=" => Token::SymModuloEqual,
        "&=" => Token::SymAndEqual,
        "|=" => Token::SymOrEqual,
        "^=" => Token::SymXorEqual,
        ">>=" => Token::SymShiftRightAssign,
        "<<=" => Token::SymShiftLeftAssign,

        // keywords
        // https://www.w3.org/TR/WGSL/#keyword-summary
        "alias" => Token::KwAlias,
        "break" => Token::KwBreak,
        "case" => Token::KwCase,
        "const" => Token::KwConst,
        "const_assert" => Token::KwConstAssert,
        "continue" => Token::KwContinue,
        "continuing" => Token::KwContinuing,
        "default" => Token::KwDefault,
        "diagnostic" => Token::KwDiagnostic,
        "discard" => Token::KwDiscard,
        "else" => Token::KwElse,
        "enable" => Token::KwEnable,
        "false" => Token::KwFalse,
        "fn" => Token::KwFn,
        "for" => Token::KwFor,
        "if" => Token::KwIf,
        "let" => Token::KwLet,
        "loop" => Token::KwLoop,
        "override" => Token::KwOverride,
        "requires" => Token::KwRequires,
        "return" => Token::KwReturn,
        "struct" => Token::KwStruct,
        "switch" => Token::KwSwitch,
        "true" => Token::KwTrue,
        "var" => Token::KwVar,
        "while" => Token::KwWhile,

        IdentPatternToken => Token::Ident(<String>),
        TokAbstractInt => Token::AbstractInt(<i64>),
        TokAbstractFloat => Token::AbstractFloat(<f64>),
        TokI32 => Token::I32(<i32>),
        TokU32 => Token::U32(<u32>),
        TokF32 => Token::F32(<f32>),
        TokF16 => Token::F16(<f32>),
        TokTemplateArgsStart => Token::TemplateArgsStart,
        TokTemplateArgsEnd => Token::TemplateArgsEnd,

        // extension: wesl-imports
        // https://github.com/wgsl-tooling-wg/wesl-spec/blob/main/Imports.md
        // date: 2024-08-29, hash: 8e3b878958980c9092ed6e45a151c6b915f5041b
        #[cfg(feature = "imports")]
        ".." => Token::SymPeriodPeriod,
        #[cfg(feature = "imports")]
        "as" => Token::KwAs,
        #[cfg(feature = "imports")]
        "import" => Token::KwImport,
    }
}

// the grammar rules are layed out in the same order as in the spec.
// follwing the spec at this date: https://www.w3.org/TR/2024/WD-WGSL-20240731/

// custom entrypoint called by the lexer when it sees [Token::Ident, Token::SymLessThan].
// if this parse succeeds, the next token emitted by the lexer will be TokTemplateList.
// pub TryTemplateList: Span = {
//    <l:@L> TokTemplateArgsStart TemplateArgCommaList TokTemplateArgsEnd <r:@R> => { (l..r) },
//};

// =====================
// === Begin grammar ===
// =====================

// 2. WGSL MODULE
// https://www.w3.org/TR/WGSL/#wgsl-module

#[cfg(not(feature = "imports"))]
pub TranslationUnit: TranslationUnit = {
    <global_directives: GlobalDirective*> <global_declarations: GlobalDecl*> => TranslationUnit {
        global_directives, global_declarations
    },
};

GlobalDecl: GlobalDeclaration = {
    ";"                        => GlobalDeclaration::Void,
    <GlobalVariableDecl> ";"   => GlobalDeclaration::Declaration(<>),
    <GlobalValueDecl> ";"      => GlobalDeclaration::Declaration(<>),
    <TypeAliasDecl> ";"        => GlobalDeclaration::TypeAlias(<>),
    <StructDecl>               => GlobalDeclaration::Struct(<>),
    <FunctionDecl>             => GlobalDeclaration::Function(<>),
    <ConstAssertStatement> ";" => GlobalDeclaration::ConstAssert(<>),
};

DiagnosticRuleName: String = {
    DiagnosticNameToken,
    <first: DiagnosticNameToken> "." <last: DiagnosticNameToken> => format!("{first}.{last}"),
};

// 3. TEXTUAL STRUCTURE
// https://www.w3.org/TR/WGSL/textual-structure#

// XXX: non-conformant
// https://www.w3.org/TR/WGSL/#syntax-literal
Literal: LiteralExpression = {
    TokAbstractInt   => LiteralExpression::AbstractInt(<>),
    TokAbstractFloat => LiteralExpression::AbstractFloat(<>),
    TokI32           => LiteralExpression::I32(<>),
    TokU32           => LiteralExpression::U32(<>),
    TokF32           => LiteralExpression::F32(<>),
    TokF16           => LiteralExpression::F16(<>),
    BoolLiteral,
};

BoolLiteral: LiteralExpression = {
    "true"  => LiteralExpression::Bool(true),
    "false" => LiteralExpression::Bool(false),
};

Ident: String = {
    IdentPatternToken /* _DisambiguateTemplate */ => <>,
};

MemberIdent: String = {
    IdentPatternToken => <>,
};

// TODO: check context-dependent names below.

BuiltinValueName: String = {
    IdentPatternToken => <>,
};

DiagnosticNameToken: String = {
    IdentPatternToken => <>,
};

SeverityControlName: DiagnosticSeverity = {
    <l: @L> <ident: IdentPatternToken> <r: @R> =>? {
        DiagnosticSeverity::from_str(&ident).map_err(|e| lalrpop_util::ParseError::User{ error: (l, e, r) })
    },
};

EnableExtensionName: String = {
    IdentPatternToken => <>,
};

SoftwareExtensionName: String = {
    IdentPatternToken => <>,
};

InterpolateSamplingName: String = {
    IdentPatternToken => <>,
};

SwizzleName: String = {
    IdentPatternToken => <>,
};

TemplateList: Vec<TemplateArg> = {
    TokTemplateArgsStart <TemplateArgCommaList> TokTemplateArgsEnd,
};

TemplateArgCommaList: Vec<TemplateArg> = {
    Comma1<TemplateArgExpression>,
};

TemplateArgExpression: Expression = {
    Expression,
};

// 4. DIRECTIVES
// https://www.w3.org/TR/WGSL/#directives

GlobalDirective: GlobalDirective = {
    DiagnosticDirective => GlobalDirective::Diagnostic(<>),
    EnableDirective     => GlobalDirective::Enable(<>),
    RequiresDirective   => GlobalDirective::Requires(<>),
};

#[cfg(not(feature = "condcomp"))]
EnableDirective: EnableDirective = {
    "enable" <extensions: EnableExtensionList> ";" => EnableDirective {
        extensions
    },
};

EnableExtensionList: Vec<String> = {
    Comma1<EnableExtensionName>,
};

#[cfg(not(feature = "condcomp"))]
RequiresDirective: RequiresDirective = {
    "requires" <extensions: SoftwareExtensionList> ";" => RequiresDirective {
        extensions
    },
};

SoftwareExtensionList: Vec<String> = {
    Comma1<SoftwareExtensionName>,
};

#[cfg(not(feature = "condcomp"))]
DiagnosticDirective: DiagnosticDirective = {
    "diagnostic" <DiagnosticControl> ";" => {
        let (severity, rule_name) = <>;
        DiagnosticDirective { severity, rule_name }
    },
};

// 5. DECLARATION AND SCOPE
// https://www.w3.org/TR/WGSL/#declaration-and-scope

// 6. TYPES
// https://www.w3.org/TR/WGSL/#types

#[cfg(not(feature = "condcomp"))]
StructDecl: Struct = {
    "struct" <name: Ident> <members: StructBodyDecl> => Struct {
        name, members
    },
};

StructBodyDecl: Vec<StructMember> = {
    "{" <Comma1<StructMember>> "}",
};

StructMember: StructMember = {
    <attributes: Attribute*> <name: MemberIdent> ":" <ty: TypeSpecifier> => StructMember {
        attributes, name, ty
    },
};

#[cfg(not(feature = "condcomp"))]
TypeAliasDecl: TypeAlias = {
    "alias" <name: Ident> "=" <ty: TypeSpecifier> => TypeAlias {
        name, ty
    },
};

TypeSpecifier: TypeExpression = {
    TemplateElaboratedIdent => {
        let (name, template_args) = <>;
        TypeExpression { name, template_args }
    },
};

TemplateElaboratedIdent = Ident /* DisambiguateTemplate */ TemplateList?;

// 7. VARIABLE AND VALUE DECLARATIONS
// https://www.w3.org/TR/WGSL/#var-and-value

#[cfg(not(feature = "condcomp"))]
VariableOrValueStatement: Declaration = {
    VariableDecl,
    <mut decl: VariableDecl> "=" <initializer: Expression> => {
        decl.initializer = Some(initializer);
        decl
    },
    "let" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, ty) = ident;
        Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Let,
            template_args: None,
            name,
            ty,
            initializer: Some(initializer),
        }
    },
    "const" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, ty) = ident;
        Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Let,
            template_args: None,
            name,
            ty,
            initializer: Some(initializer),
        }
    },
};

#[cfg(not(feature = "condcomp"))]
VariableDecl: Declaration = {
    "var" /* DisambiguateTemplate */ <template_args: TemplateList?> <ident: OptionallyTypedIdent> => {
        let (name, ty) = ident;
        Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Var,
            template_args,
            name,
            ty,
            initializer: None,
        }
    },
};

OptionallyTypedIdent: (String, Option<TypeExpression>) = {
    <Ident> <(":" <TypeSpecifier>)?>,
};

#[cfg(not(feature = "condcomp"))]
GlobalVariableDecl: Declaration = {
    <attributes: Attribute*> <mut decl: VariableDecl> <initializer: ("=" <Expression>)?> => {
        decl.attributes = attributes;
        decl.initializer = initializer.map(Into::into);
        decl
    },
};

#[cfg(not(feature = "condcomp"))]
GlobalValueDecl: Declaration = {
    "const" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, ty) = ident;
        Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Const,
            template_args: None,
            name,
            ty,
            initializer: Some(initializer),
        }
    },
    <attributes: Attribute*> "override" <ident: OptionallyTypedIdent> <initializer: ("=" <Expression>)?> => {
        let (name, ty) = ident;
        Declaration {
            attributes,
            kind: DeclarationKind::Override,
            template_args: None,
            name,
            ty,
            initializer: initializer.map(Into::into),
        }
    },
};

// 8. EXPRESSIONS
// https://www.w3.org/TR/WGSL/#expressions

PrimaryExpression: Expression = {
    TemplateElaboratedIdent => {
        let (name, template_args) = <>;
        match template_args {
            Some(_) => Expression::Type(TypeExpression { name, template_args }),
            None => Expression::Identifier(name.into()),
        }
    }, // XXX: not sure about this one, is it type?
    CallExpression,
    Literal => Expression::Literal(<>),
    ParenExpression => Expression::Parenthesized(<>),
};

CallExpression: Expression = {
    CallPhrase => Expression::FunctionCall(<>),
};

CallPhrase: FunctionCallExpression = {
    <callee: TemplateElaboratedIdent> <arguments: ArgumentExpressionList> => {
        let (name, template_args) = callee;
        FunctionCallExpression {
            name, template_args, arguments
        }
    },
};

ParenExpression: ParenthesizedExpression = {
    "(" <Expression> ")" => ParenthesizedExpression {
        expression: <>.into()
    },
};

ArgumentExpressionList: Vec<Expression> = {
    "(" <ExpressionCommaList?> ")" => <>.unwrap_or_default(),
};

ExpressionCommaList: Vec<Expression> = {
    Comma1<Expression>,
};

// was modified from the spec, but should be equivalent
ComponentOrSwizzleSpecifier: Vec<Component> = {
    // "[" Expression "]" ComponentOrSwizzleSpecifier?,
    // "." MemberIdent ComponentOrSwizzleSpecifier?,
    // "." SwizzleName ComponentOrSwizzleSpecifier ?,
    SingleComponentOrSwizzleSpecifier+
};

SingleComponentOrSwizzleSpecifier: Component = {
    "[" <Expression> "]" => Component::Index(<>.into()),
    "." <MemberIdent>       => Component::Named(<>),
}

UnaryExpression: Expression = {
    SingularExpression,
    "-" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::Negation, operand: operand.into()
    }),
    "!" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::LogicalNegation, operand: operand.into()
    }),
    "~" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::BitwiseComplement, operand: operand.into()
    }),
    "*" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::Indirection, operand: operand.into()
    }),
    "&" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::AddressOf, operand: operand.into()
    }),
};

SingularExpression: Expression = {
    <expr: PrimaryExpression> <components: ComponentOrSwizzleSpecifier?> => match components {
        Some(components) => apply_components(components, expr),
        None => expr
    },
};

LhsExpression: Expression = {
    <expr: CoreLhsExpression> <components: ComponentOrSwizzleSpecifier?> => match components {
        Some(components) => apply_components(components, expr),
        None => expr
    },
    "*" <operand: LhsExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::Indirection, operand: operand.into()
    }),
    "&" <operand: LhsExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::AddressOf, operand: operand.into()
    }),
 };
 
CoreLhsExpression: Expression = {
    Ident /* DisambiguateTemplate */ => Expression::Identifier(<>.into()),
    "(" <LhsExpression> ")" => Expression::Parenthesized(ParenthesizedExpression {
        expression: <>.into()
    }),
};

MultiplicativeExpression: Expression = {
    UnaryExpression,
    <left: MultiplicativeExpression> <operator: MultiplicativeOperator> <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator, left: left.into(), right: right.into()
    }),
};

MultiplicativeOperator: BinaryOperator = {
    "*" => BinaryOperator::Multiplication,
    "/" => BinaryOperator::Division,
    "%" => BinaryOperator::Remainder,
};
 
AdditiveExpression: Expression = {
    MultiplicativeExpression,
    <left: AdditiveExpression> <operator: AdditiveOperator> <right: MultiplicativeExpression> => Expression::Binary(BinaryExpression {
        operator, left: left.into(), right: right.into()
    }),
};

AdditiveOperator: BinaryOperator = {
    "+" => BinaryOperator::Addition,
    "-" => BinaryOperator::Subtraction,
};

ShiftExpression: Expression = {
    AdditiveExpression,
    <left: UnaryExpression> "<<" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShiftLeft, left: left.into(), right: right.into()
    }),
    <left: UnaryExpression> ">>" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShiftRight, left: left.into(), right: right.into()
    }),
};

RelationalExpression: Expression = {
    ShiftExpression,
    <left: ShiftExpression> "<" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::LessThan, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> ">" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::GreaterThan, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> "<=" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::LessThanEqual, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> ">=" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::GreaterThanEqual, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> "==" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::Equality, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> "!=" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::Inequality, left: left.into(), right: right.into()
    }),
};

ShortCircuitAndExpression: Expression = {
    RelationalExpression,
    <left: ShortCircuitAndExpression> "&&" <right: RelationalExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShortCircuitAnd, left: left.into(), right: right.into()
    }),
 };
 
ShortCircuitOrExpression: Expression = {
    RelationalExpression,
    <left: ShortCircuitOrExpression> "||" <right: RelationalExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShortCircuitOr, left: left.into(), right: right.into()
    }),
 };
 
BinaryOrExpression: Expression = {
    UnaryExpression,
    <left: BinaryOrExpression> "|" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseOr, left: left.into(), right: right.into()
    }),
};

BinaryAndExpression: Expression = {
    UnaryExpression,
    <left: BinaryAndExpression> "&" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseAnd, left: left.into(), right: right.into()
    }),
};

BinaryXorExpression: Expression = {
    UnaryExpression,
    <left: BinaryXorExpression> "^" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseXor, left: left.into(), right: right.into()
    }),
};

BitwiseExpression: Expression = {
    <left: BinaryAndExpression> "&" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseAnd, left: left.into(), right: right.into()
    }),
    <left: BinaryOrExpression> "|" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseOr, left: left.into(), right: right.into()
    }),
    <left: BinaryXorExpression> "^" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseXor, left: left.into(), right: right.into()
    }),
};

Expression: Expression = {
    RelationalExpression,
    <left: ShortCircuitOrExpression> "||" <right: RelationalExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShortCircuitOr, left: left.into(), right: right.into()
    }),
    <left: ShortCircuitAndExpression> "&&" <right: RelationalExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShortCircuitAnd, left: left.into(), right: right.into()
    }),
    BitwiseExpression,
};

// 9. STATEMENTS
// https://www.w3.org/TR/WGSL/#statements


CompoundStatement: CompoundStatement = {
    <attributes: Attribute*> "{" <statements: Statement*> "}" => CompoundStatement {
        attributes, statements
    },
};

#[cfg(not(feature = "condcomp"))]
AssignmentStatement: AssignmentStatement = {
    <lhs: LhsExpression> "=" <rhs: Expression> => AssignmentStatement {
        operator: AssignmentOperator::Equal, lhs, rhs
    },
    <lhs: LhsExpression> <operator: CompoundAssignmentOperator> <rhs: Expression> => AssignmentStatement {
        operator, lhs, rhs
    },
    "_" "=" <rhs: Expression> => {
        let lhs = Expression::Identifier("_".to_string().into());
        AssignmentStatement { operator: AssignmentOperator::Equal, lhs, rhs }
    },
};

CompoundAssignmentOperator: AssignmentOperator = {
    "+=" => AssignmentOperator::PlusEqual,
    "-=" => AssignmentOperator::MinusEqual,
    "*=" => AssignmentOperator::TimesEqual,
    "/=" => AssignmentOperator::DivisionEqual,
    "%=" => AssignmentOperator::ModuloEqual,
    "&=" => AssignmentOperator::AndEqual,
    "|=" => AssignmentOperator::OrEqual,
    "^=" => AssignmentOperator::XorEqual,
    ">>=" => AssignmentOperator::ShiftRightAssign,
    "<<=" => AssignmentOperator::ShiftLeftAssign,
};

#[cfg(not(feature = "condcomp"))]
IncrementStatement: IncrementStatement = {
    <expression: LhsExpression> "++" => IncrementStatement {
        expression
    },
};

#[cfg(not(feature = "condcomp"))]
DecrementStatement: DecrementStatement = {
    <expression: LhsExpression> "--" => DecrementStatement {
        expression
    },
};

IfStatement: IfStatement = {
    <attributes: Attribute*> <if_clause: IfClause> <else_if_clauses: ElseIfClause*> <else_clause: ElseClause?> => IfStatement {
        attributes, if_clause, else_if_clauses, else_clause
    },
};

IfClause: IfClause = "if" <expression: Expression> <body: CompoundStatement> => IfClause {
    expression, body
};

#[cfg(not(feature = "condcomp"))]
ElseIfClause: ElseIfClause = "else" "if" <expression: Expression> <body: CompoundStatement> => ElseIfClause {
    expression, body
};

#[cfg(not(feature = "condcomp"))]
ElseClause: ElseClause = "else" <body: CompoundStatement> => ElseClause {
    body
};

SwitchStatement: SwitchStatement = {
    <attributes: Attribute*> "switch" <expression: Expression> <body: SwitchBody> => {
        let (body_attributes, clauses) = body;
        SwitchStatement {
            attributes, expression, body_attributes, clauses
        }
    },
};

SwitchBody: (Vec<Attribute>, Vec<SwitchClause>) = {
    <Attribute*> "{" <SwitchClause+> "}",
};

SwitchClause: SwitchClause = {
    CaseClause,
    DefaultAloneClause,
};

#[cfg(not(feature = "condcomp"))]
CaseClause: SwitchClause = {
    "case" <case_selectors: CaseSelectors> ":"? <body: CompoundStatement> => SwitchClause {
        case_selectors, body
    },
};

#[cfg(not(feature = "condcomp"))]
DefaultAloneClause: SwitchClause = {
    "default" ":"? <body: CompoundStatement> => SwitchClause {
        case_selectors: vec![CaseSelector::Default], body
    },
};

CaseSelectors: Vec<CaseSelector> = {
    Comma1<CaseSelector>,
};

CaseSelector: CaseSelector = {
    "default" => CaseSelector::Default,
    Expression => CaseSelector::Expression(<>),
};

LoopStatement: LoopStatement = {
    <attributes: Attribute*> "loop" <body_attributes: Attribute*> "{" <statements: Statement*> <continuing: ContinuingStatement?> "}" => {
        let body = CompoundStatement { attributes: body_attributes, statements };
        LoopStatement {
            attributes, body, continuing
        }
    },
};

ForStatement: ForStatement = {
     <attributes: Attribute*> "for" "(" <header: ForHeader> ")" <body: CompoundStatement> => {
        let (initializer, condition, update) = header;
        ForStatement {
            attributes, initializer: initializer.map(Into::into), condition, update: update.map(Into::into), body
        }
    },
};

ForHeader: (Option<Statement>, Option<Expression>, Option<Statement>) = {
    <ForInit?> ";" <Expression?> ";" <ForUpdate?>,
};

ForInit: Statement = {
    VariableOrValueStatement  => Statement::Declaration(<>),
    VariableUpdatingStatement => <>,
    FuncCallStatement         => Statement::FunctionCall(<>),
};

ForUpdate: Statement = {
    VariableUpdatingStatement => <>,
    FuncCallStatement         => Statement::FunctionCall(<>),
};

WhileStatement: WhileStatement = {
    <attributes: Attribute*> "while" <condition: Expression> <body: CompoundStatement> => WhileStatement {
        attributes, condition, body
    },
};

#[cfg(not(feature = "condcomp"))]
BreakStatement: BreakStatement = {
    "break" => BreakStatement {},
};

#[cfg(not(feature = "condcomp"))]
BreakIfStatement: BreakIfStatement = {
    "break" "if" <expression: Expression> ";" => BreakIfStatement {
        expression
    },
};

#[cfg(not(feature = "condcomp"))]
ContinueStatement: ContinueStatement = {
    "continue" => ContinueStatement {},
};

#[cfg(not(feature = "condcomp"))]
ContinuingStatement = "continuing" <ContinuingCompoundStatement>;

#[cfg(not(feature = "condcomp"))]
ContinuingCompoundStatement: ContinuingStatement = {
    <attributes: Attribute*> "{" <statements: Statement*> <break_if: BreakIfStatement?> "}" => {
        let body = CompoundStatement { attributes, statements };
        ContinuingStatement { body, break_if }
    },
};

#[cfg(not(feature = "condcomp"))]
ReturnStatement: ReturnStatement = {
    "return" <expression: Expression?> => ReturnStatement {
        expression
    },
};

#[cfg(not(feature = "condcomp"))]
DiscardStatement: DiscardStatement = {
    "discard" => DiscardStatement {},
};

#[cfg(not(feature = "condcomp"))]
FuncCallStatement: FunctionCallStatement = <call: CallPhrase> => FunctionCallStatement {
    call
};

#[cfg(not(feature = "condcomp"))]
ConstAssertStatement: ConstAssertStatement = {
    "const_assert" <expression: Expression> => ConstAssertStatement {
        expression
    },
};

Statement: Statement = {
    ";" => Statement::Void,
    <ReturnStatement> ";" => Statement::Return(<>),
    <IfStatement> => Statement::If(<>),
    <SwitchStatement> => Statement::Switch(<>),
    <LoopStatement> => Statement::Loop(<>),
    <ForStatement> => Statement::For(<>),
    <WhileStatement> => Statement::While(<>),
    <FuncCallStatement> ";" => Statement::FunctionCall(<>),
    <VariableOrValueStatement> ";" => Statement::Declaration(<>),
    <BreakStatement> ";" => Statement::Break(<>),
    <ContinueStatement> ";" => Statement::Continue(<>),
    <DiscardStatement> ";" => Statement::Discard(<>),
    <VariableUpdatingStatement> ";" => <>,
    <CompoundStatement> => Statement::Compound(<>),
    <ConstAssertStatement> ";" => Statement::ConstAssert(<>),
};

VariableUpdatingStatement: Statement = {
    AssignmentStatement => Statement::Assignment(<>),
    IncrementStatement => Statement::Increment(<>),
    DecrementStatement => Statement::Decrement(<>),
};

// 10. FUNCTIONS
// https://www.w3.org/TR/WGSL/#functions

FunctionDecl: Function = {
    <attributes: Attribute*> <header: FunctionHeader> <body: CompoundStatement> => {
        let (name, parameters, return_attributes, return_type) = header;
        Function { attributes, name, parameters, return_attributes, return_type, body }
    },
};

FunctionHeader: (String, Vec<FormalParameter>, Vec<Attribute>, Option<TypeExpression>) = {
    "fn" <name: Ident> "(" <parameters: ParamList?> ")" <ret: ("->" <Attribute*> <TemplateElaboratedIdent>)?> => {
        let (return_attributes, return_type) = ret.map(|(return_attributes, (name, template_args))| {
            let return_type = TypeExpression {name, template_args };
            (return_attributes, Some(return_type))
        }).unwrap_or_default();
        let parameters = parameters.unwrap_or_default();
        (name, parameters, return_attributes, return_type)
    },
};

ParamList: Vec<FormalParameter> = {
    Comma1<Param>,
};

Param: FormalParameter = {
    <attributes: Attribute*> <name: Ident> ":" <ty: TypeSpecifier> => FormalParameter {
        attributes, name, ty
    },
};

// 11. ATTRIBUTES
// https://www.w3.org/TR/WGSL/#attributes

// TODO: maybe parse the well-known attributes.
#[cfg(not(feature = "condcomp"))]
Attribute: Attribute = {
    "@" <name: IdentPatternToken> <arguments: ArgumentExpressionList?> => Attribute {
        name, arguments
    }
};

DiagnosticControl: (DiagnosticSeverity, String) = {
    "(" <SeverityControlName> "," <DiagnosticRuleName> ","? ")",
};

// EXTENSION: WESL-IMPORTS
// https://github.com/wgsl-tooling-wg/wesl-spec/blob/main/Imports.md
// date: 2024-08-29, hash: 8e3b878958980c9092ed6e45a151c6b915f5041b

#[cfg(feature = "imports")]
pub TranslationUnit: TranslationUnit = {
    <imports: Import*> <global_directives: GlobalDirective*> <global_declarations: GlobalDecl*> => TranslationUnit {
        imports, global_directives, global_declarations
    },
};

#[cfg(all(feature = "imports", not(feature = "condcomp")))]
Import: Import = {
    "import" <relative: ImportRelative?> <mut import: ImportPath> ";" => match relative {
        Some(mut relative) => {
            relative.extend(import.path);
            import.path = relative;
            import
        },
        None => import,
    }
};

#[cfg(all(feature = "imports", feature = "condcomp"))]
Import: Import = {
    <attributes: Attribute*> "import" <relative: ImportRelative?> <mut import: ImportPath> ";" => {
        let mut import = match relative {
            Some(mut relative) => {
                relative.extend(&import.path);
                import.path = relative;
                import
            },
            None => import,
        };
        import.attributes = attributes;
        import
    }
};

#[cfg(feature = "imports")]
ImportRelative: std::path::PathBuf = {
    "." "/" <parents: (".." "/")*> => {
        std::iter::once(".").chain(parents.iter().map(|_| "..")).map(str::to_string).collect()
    },
    ".." "/" <parents: (".." "/")*> => {
        std::iter::once("..").chain(parents.iter().map(|_| "..")).map(str::to_string).collect()
    },
};

#[cfg(feature = "imports")]
ImportPath: Import = {
    <path: (<Ident> "/")+> <content: ImportContent> => Import {
        #[cfg(feature = "condcomp")] attributes: Vec::new(),
        path: std::path::PathBuf::from_iter(path.iter()), content
    },
    ItemImport => Import {
        #[cfg(feature = "condcomp")] attributes: Vec::new(),
        path: Default::default(), content: ImportContent::Item(<>)
    },
    StarImport => Import {
        #[cfg(feature = "condcomp")] attributes: Vec::new(),
        path: Default::default(), content: ImportContent::Star(<>)
    },
};

#[cfg(feature = "imports")]
ImportContent: ImportContent = {
    ImportCollection => ImportContent::Collection(<>),
    ItemImport => ImportContent::Item(<>),
    StarImport => ImportContent::Item(<>),
};

#[cfg(feature = "imports")]
StarImport: ImportItem = {
    <name: Ident> "/" "*" <rename: ("as" <Ident>)?> => ImportItem {
        name, rename
    }
};

#[cfg(feature = "imports")]
ItemImport: ImportItem = {
    <name: Ident> <rename: ("as" <Ident>)?> => ImportItem {
        name, rename
    }
};

#[cfg(feature = "imports")]
ImportCollection: Vec<Import> = {
    "{" <Comma1<ImportPath>> "}"
};

// EXTENSION: WESL-CONDITIONAL-TRANSLATION
// https://github.com/wgsl-tooling-wg/wesl-spec/pull/19
// date: 2024-09-14, hash: b1446356ff206e5826a58812895bc6d3d64a2220

#[cfg(feature = "condcomp")]
Attribute: Attribute = {
    "@" <name: IdentPatternToken> <arguments: ArgumentExpressionList?> => Attribute {
        name, arguments
    },
    "@" "if" <arguments: ArgumentExpressionList?> => Attribute {
        name: "if".to_string(), arguments
    },
};

#[cfg(feature = "condcomp")]
EnableDirective: EnableDirective = {
    <attributes: Attribute*> "enable" <extensions: EnableExtensionList> ";" => EnableDirective {
        attributes, extensions
    },
};

#[cfg(feature = "condcomp")]
RequiresDirective: RequiresDirective = {
    <attributes: Attribute*> "requires" <extensions: SoftwareExtensionList> ";" => RequiresDirective {
        attributes, extensions
    },
};

#[cfg(feature = "condcomp")]
DiagnosticDirective: DiagnosticDirective = {
    <Attribute*> "diagnostic" <DiagnosticControl> ";" => {
        let (attributes, (severity, rule_name)) = (<>);
        DiagnosticDirective { attributes, severity, rule_name }
    },
};

#[cfg(feature = "condcomp")]
StructDecl: Struct = {
    <attributes: Attribute*> "struct" <name: Ident> <members: StructBodyDecl> => Struct {
        attributes, name, members
    },
};

#[cfg(feature = "condcomp")]
TypeAliasDecl: TypeAlias = {
    <attributes: Attribute*> "alias" <name: Ident> "=" <ty: TypeSpecifier> => TypeAlias {
        attributes, name, ty
    },
};

#[cfg(feature = "condcomp")]
VariableOrValueStatement: Declaration = {
    VariableDecl,
    <mut decl: VariableDecl> "=" <initializer: Expression> => {
        decl.initializer = Some(initializer);
        decl
    },
    <attributes: Attribute*> "let" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, ty) = ident;
        Declaration {
            attributes,
            kind: DeclarationKind::Let,
            template_args: None,
            name,
            ty,
            initializer: Some(initializer),
        }
    },
    <attributes: Attribute*> "const" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, ty) = ident;
        Declaration {
            attributes,
            kind: DeclarationKind::Let,
            template_args: None,
            name,
            ty,
            initializer: Some(initializer),
        }
    },
};

#[cfg(feature = "condcomp")]
VariableDecl: Declaration = {
    <attributes: Attribute*> "var" /* DisambiguateTemplate */ <template_args: TemplateList?> <ident: OptionallyTypedIdent> => {
        let (name, ty) = ident;
        Declaration {
            attributes,
            kind: DeclarationKind::Var,
            template_args,
            name,
            ty,
            initializer: None,
        }
    },
};

#[cfg(feature = "condcomp")]
GlobalVariableDecl: Declaration = {
    <mut decl: VariableDecl> <initializer: ("=" <Expression>)?> => {
        decl.initializer = initializer.map(Into::into);
        decl
    },
};

#[cfg(feature = "condcomp")]
GlobalValueDecl: Declaration = {
    <attributes: Attribute*> "const" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, ty) = ident;
        Declaration {
            attributes,
            kind: DeclarationKind::Const,
            template_args: None,
            name,
            ty,
            initializer: Some(initializer),
        }
    },
    <attributes: Attribute*> "override" <ident: OptionallyTypedIdent> <initializer: ("=" <Expression>)?> => {
        let (name, ty) = ident;
        Declaration {
            attributes,
            kind: DeclarationKind::Override,
            template_args: None,
            name,
            ty,
            initializer: initializer.map(Into::into),
        }
    },
};

#[cfg(feature = "condcomp")]
AssignmentStatement: AssignmentStatement = {
    <lhs: LhsExpression> "=" <rhs: Expression> => AssignmentStatement {
        attributes: vec![], operator: AssignmentOperator::Equal, lhs, rhs
    },
    <lhs: LhsExpression> <operator: CompoundAssignmentOperator> <rhs: Expression> => AssignmentStatement {
        attributes: vec![], operator, lhs, rhs
    },
    "_" "=" <rhs: Expression> => {
        let lhs = Expression::Identifier("_".to_string().into());
        AssignmentStatement { attributes: vec![], operator: AssignmentOperator::Equal, lhs, rhs }
    },
};

#[cfg(feature = "condcomp")]
IncrementStatement: IncrementStatement = {
    <expression: LhsExpression> "++" => IncrementStatement {
        attributes: vec![], expression
    },
};

#[cfg(feature = "condcomp")]
DecrementStatement: DecrementStatement = {
    <expression: LhsExpression> "--" => DecrementStatement {
        attributes: vec![], expression
    },
};

#[cfg(feature = "condcomp")]
ElseIfClause: ElseIfClause = "else" "if" <expression: Expression> <body: CompoundStatement> => ElseIfClause {
    attributes: vec![], expression, body
};

#[cfg(feature = "condcomp")]
ElseClause: ElseClause = "else" <body: CompoundStatement> => ElseClause {
    attributes: vec![], body
};

#[cfg(feature = "condcomp")]
CaseClause: SwitchClause = {
    <attributes: Attribute*> "case" <case_selectors: CaseSelectors> ":"? <body: CompoundStatement> => SwitchClause {
        attributes, case_selectors, body
    },
};

#[cfg(feature = "condcomp")]
DefaultAloneClause: SwitchClause = {
    <attributes: Attribute*> "default" ":"? <body: CompoundStatement> => SwitchClause {
        attributes, case_selectors: vec![CaseSelector::Default], body
    },
};

#[cfg(feature = "condcomp")]
BreakStatement: BreakStatement = {
    <attributes: Attribute*> "break" => BreakStatement {
        attributes
    },
};

#[cfg(feature = "condcomp")]
BreakIfStatement: BreakIfStatement = {
    <attributes: Attribute*> "break" "if" <expression: Expression> ";" => BreakIfStatement {
        attributes, expression
    },
};

#[cfg(feature = "condcomp")]
ContinueStatement: ContinueStatement = {
    <attributes: Attribute*> "continue" => ContinueStatement {
        attributes
    },
};

#[cfg(feature = "condcomp")]
ContinuingStatement: ContinuingStatement = <Attribute*> "continuing" <ContinuingCompoundStatement> => {
    let (attributes, mut statement) = (<>);
    statement.attributes = attributes;
    statement
};

#[cfg(feature = "condcomp")]
ContinuingCompoundStatement: ContinuingStatement = {
    <attributes: Attribute*> "{" <statements: Statement*> <break_if: BreakIfStatement?> "}" => {
        let body = CompoundStatement { attributes, statements };
        ContinuingStatement { attributes: Vec::new(), body, break_if }
    },
};

#[cfg(feature = "condcomp")]
ReturnStatement: ReturnStatement = {
    <attributes: Attribute*> "return" <expression: Expression?> => ReturnStatement {
        attributes, expression
    },
};

#[cfg(feature = "condcomp")]
DiscardStatement: DiscardStatement = {
    <attributes: Attribute*> "discard" => DiscardStatement {
        attributes
    },
};

#[cfg(feature = "condcomp")]
FuncCallStatement: FunctionCallStatement = <attributes: Attribute*> <call: CallPhrase> => FunctionCallStatement {
    attributes, call
};

#[cfg(feature = "condcomp")]
ConstAssertStatement: ConstAssertStatement = {
    <attributes: Attribute*> "const_assert" <expression: Expression> => ConstAssertStatement {
        attributes, expression
    },
};

// ===================
// === End grammar ===
// ===================

// ----------- below: macros -----------

Comma<T>: Vec<T> = {
    <mut v: (<T> ",")*> <e: T?> => match e {
        Some(e) => {
            v.push(e);
            v
        }
        None => v,
    }
};

Comma1<T> = Sep1<",", T>;

Sep1<S, T>: Vec<T> = {
    <mut v: (<T> S)*> <e: T> S? => {
        v.push(e);
        v
    }
};
