use crate::parser::ast::*;

grammar(idents: &mut Vec<Span>);

// this grammar follows quite closely the one proposed in wgsl spec.
// https://www.w3.org/TR/WGSL/#recursive-descent-syntax-global_decl

pub TranslationUnit: () = GlobalDirective * GlobalDecl *;

// TODO: incomplete
GlobalDirective: () = {
    r"diagnostic[^;]*;",
    r"enable[^;]*;",
    r"requires[^;]*;",
};

GlobalDecl: () = {
    ";",
    GlobalVariableDecl ";",
    GlobalValueDecl ";",
    TypeAliasDecl ";",
    StructDecl,
    FunctionDecl,
    ConstAssertStatement ";",
};

// type
// https://www.w3.org/TR/WGSL/#type-aliases
// https://www.w3.org/TR/WGSL/#type-specifiers

TypeAliasDecl: () = "alias" Ident "=" TypeSpecifier;

TypeSpecifier: () = TemplateElaboratedIdent;

TemplateElaboratedIdent: () = Ident Template ?;

// struct
// https://www.w3.org/TR/WGSL/#struct-types

StructDecl: () = "struct" Ident StructBodyDecl;

StructBodyDecl: () = "{" StructMember ( "," StructMember ) * "," ? "}";

StructMember: () = Attribute * MemberIdent ":" TypeSpecifier;

// ident
// https://www.w3.org/TR/WGSL/#identifiers
// https://www.w3.org/TR/WGSL/#syntax-ident_pattern_token

Ident: () = IdentPatternToken;

MemberIdent: () = IdentPatternToken;

IdentPatternToken: () =  r"([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])";

// function
// https://www.w3.org/TR/WGSL/#function-declaration-sec

FunctionDecl: () = Attribute * FunctionHeader CompoundStatement;

FunctionHeader: () = "fn" Ident "(" ParamList ? ")" ( "->" Attribute * TemplateElaboratedIdent ) ?;

ParamList: () = Param ( "," Param ) * "," ?;

Param: () = Attribute * Ident ":" TypeSpecifier;

// statement
// https://www.w3.org/TR/WGSL/#statements-summary

Statement: () = {
    ";",
    ReturnStatement ";",
    IfStatement,
    SwitchStatement,
    LoopStatement,
    ForStatement,
    WhileStatement,
    FuncCallStatement ";",
    VariableOrValueStatement ";",
    BreakStatement ";",
    ContinueStatement ";",
    "discard" ";",
    VariableUpdatingStatement ";",
    CompoundStatement,
    ConstAssertStatement ";",
};

VariableUpdatingStatement: () = {
    AssignmentStatement,
    IncrementStatement,
    DecrementStatement,
};

// return statement
// https://www.w3.org/TR/WGSL/#return-statement

ReturnStatement: () = "return" Expression ?;

// if statement
// https://www.w3.org/TR/WGSL/#syntax-if_statement

IfStatement: () = Attribute * IfClause ElseIfClause * ElseClause ?;

IfClause: () = "if" Expression CompoundStatement;

ElseIfClause: () = "else" "if" Expression CompoundStatement;

ElseClause: () = "else" CompoundStatement;

// switch statement
// https://www.w3.org/TR/WGSL/#switch-statement

SwitchStatement: () = Attribute * "switch" Expression SwitchBody;

SwitchBody: () = Attribute * "{" SwitchClause + "}";

SwitchClause: () = {
    CaseClause,
    DefaultAloneClause,
};

CaseClause: () = "case" CaseSelectors ":" ? CompoundStatement;

DefaultAloneClause: () = "default" ":" ? CompoundStatement;

CaseSelectors: () = CaseSelector ( "," CaseSelector ) * "," ?;

CaseSelector: () = {
    "default",
    Expression,
};

// loop statement
// https://www.w3.org/TR/WGSL/#loop-statement

LoopStatement: () = Attribute * "loop" Attribute * "{" Statement * ContinuingStatement ? "}";

// for statement
// https://www.w3.org/TR/WGSL/#syntax-for_statement

ForStatement: () = Attribute * "for" "(" ForHeader ")" CompoundStatement;

ForHeader: () = ForInit ? ";" Expression ? ";" ForUpdate ?;

ForInit: () = {
    VariableOrValueStatement,
    VariableUpdatingStatement,
    FuncCallStatement,
};

ForUpdate: () = {
    VariableUpdatingStatement,
    FuncCallStatement,
};

// while statement
// https://www.w3.org/TR/WGSL/#syntax-while_statement

WhileStatement: () = Attribute * "while" Expression CompoundStatement;

// function call statement
// https://www.w3.org/TR/WGSL/#syntax-func_call_statement

FuncCallStatement: () = CallPhrase;

// variable and value declaration
// https://www.w3.org/TR/WGSL/#var-and-value-decl-grammar

VariableOrValueStatement: () = {
    VariableDecl,
    VariableDecl "=" Expression,
    "let" OptionallyTypedIdent "=" Expression,
    "const" OptionallyTypedIdent "=" Expression,
};

VariableDecl: () = "var" Template ? OptionallyTypedIdent;

OptionallyTypedIdent: () = Ident ( ":" TypeSpecifier ) ?;

GlobalVariableDecl: () = Attribute * VariableDecl ( "=" Expression ) ?;

GlobalValueDecl: () = {
    "const" OptionallyTypedIdent "=" Expression,
    Attribute * "override" OptionallyTypedIdent ( "=" Expression ) ?,
};

// break statement
// https://www.w3.org/TR/WGSL/#break-statement

BreakStatement: () = "break";

// break-if statement
// https://www.w3.org/TR/WGSL/#break-if-statement

BreakIfStatement: () = "break" "if" Expression ";";

// continue statement
// https://www.w3.org/TR/WGSL/#continue-statement

ContinueStatement: () = "continue";

// continuing statement
// https://www.w3.org/TR/WGSL/#continuing-statement

ContinuingStatement: () = "continuing" ContinuingCompoundStatement;

ContinuingCompoundStatement: () = Attribute * "{" Statement * BreakIfStatement ? "}";

// compound statement
// https://www.w3.org/TR/WGSL/#compound-statement-section

CompoundStatement: () = Attribute * "{" Statement * "}";

// assignment statement
// https://www.w3.org/TR/WGSL/#assignment

AssignmentStatement: () = {
     LhsExpression "=" Expression,
     LhsExpression CompoundAssignmentOperator Expression,
    "_" "=" Expression,
};

CompoundAssignmentOperator: () = {
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "&=",
    "|=",
    "^=",
    ">>=",
    "<<=",
};

// increment decrement statement

IncrementStatement: () = LhsExpression "++";

DecrementStatement: () = LhsExpression "--";

// const_assert statement
// https://www.w3.org/TR/WGSL/#const-assert-statement

ConstAssertStatement: () = "const_assert" Expression;

// expression
// https://www.w3.org/TR/WGSL/#expression-grammar

PrimaryExpression: () = {
    TemplateElaboratedIdent,
    CallExpression,
    Literal,
    ParenExpression,
};

CallExpression: () = CallPhrase;

CallPhrase: () = TemplateElaboratedIdent ArgumentExpressionList;

ParenExpression: () = "(" Expression ")";

ArgumentExpressionList: () = "(" ExpressionCommaList ? ")";

ExpressionCommaList: () = Expression ( "," Expression ) * "," ?;

ComponentOrSwizzleSpecifier: () = {
    "[" Expression "]" ComponentOrSwizzleSpecifier ?,
    "." MemberIdent ComponentOrSwizzleSpecifier ?,
    // "." SwizzleName ComponentOrSwizzleSpecifier ?,
};

UnaryExpression: () = {
    SingularExpression,
    "-" UnaryExpression,
    "!" UnaryExpression,
    "~" UnaryExpression,
    "*" UnaryExpression,
    "&" UnaryExpression,
};

SingularExpression: () = PrimaryExpression ComponentOrSwizzleSpecifier ?;

LhsExpression: () = {
    CoreLhsExpression ComponentOrSwizzleSpecifier ?,
    "*" LhsExpression,
    "&" LhsExpression,
 };
 
CoreLhsExpression: () = {
    Ident, // DisambiguateTemplate
    "(" LhsExpression ")",
};

MultiplicativeExpression: () = {
    UnaryExpression,
    MultiplicativeExpression MultiplicativeOperator UnaryExpression,
};

MultiplicativeOperator: () = {
    "*",
    "/",
    "%",
};
 
AdditiveExpression: () = {
    MultiplicativeExpression,
    AdditiveExpression AdditiveOperator MultiplicativeExpression,
};

AdditiveOperator: () = {
    "+",
    "-",
};

ShiftExpression: () = {
    AdditiveExpression,
    UnaryExpression "<<" UnaryExpression,
    UnaryExpression ">>" UnaryExpression,
};

RelationalExpression: () = {
    ShiftExpression,
    ShiftExpression "<" ShiftExpression,
    ShiftExpression ">" ShiftExpression,
    ShiftExpression "<=" ShiftExpression,
    ShiftExpression ">=" ShiftExpression,
    ShiftExpression "==" ShiftExpression,
    ShiftExpression "!=" ShiftExpression,
};

ShortCircuitAndExpression: () = {
    RelationalExpression,
    ShortCircuitAndExpression "&&" RelationalExpression,
 };
 
ShortCircuitOrExpression: () = {
    RelationalExpression,
    ShortCircuitOrExpression "||" RelationalExpression,
 };
 
BinaryOrExpression: () = {
    UnaryExpression,
    BinaryOrExpression "|" UnaryExpression,
};

BinaryAndExpression: () = {
    UnaryExpression,
    BinaryAndExpression "&" UnaryExpression,
};

BinaryXorExpression: () = {
    UnaryExpression,
    BinaryXorExpression "^" UnaryExpression,
};

BitwiseExpression: () = {
    BinaryAndExpression "&" UnaryExpression,
    BinaryOrExpression "|" UnaryExpression,
    BinaryXorExpression "^" UnaryExpression,
};

Expression: () = {
    RelationalExpression,
    ShortCircuitOrExpression "||" RelationalExpression,
    ShortCircuitAndExpression "&&" RelationalExpression,
    BitwiseExpression,
};


// other

// TODO: incomplete
Template: () = r"<[^>]*>";

// TODO: incomplete
Attribute: () =  r"@\w+(?:\s*\([^\)]*\))?";

// TODO: test & simplify
Literal: () = {
    "true",
    "false",
    r"(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[iufh]?",
    r"0[xX]([\da-fA-F](\.[\da-fA-F]*)?|\.[\da-fA-F]+)([pP][+-]?\d+)?[iufh]?",
    // r"0[iu]?",
    // r"[1-9][0-9]*[iu]?",
    // r"0[xX][0-9a-fA-F]+[iu]?",
    // r"0[fh]",
    // r"[1-9][0-9]*[fh]",
    // r"[0-9]*\.[0-9]+([eE][+-]?[0-9]+)?[fh]?",
    // r"[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?[fh]?",
    // r"[0-9]+[eE][+-]?[0-9]+[fh]?",
    // r"0[xX][0-9a-fA-F]*\.[0-9a-fA-F]+([pP][+-]?[0-9]+[fh]?)?",
    // r"0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*([pP][+-]?[0-9]+[fh]?)?",
    // r"0[xX][0-9a-fA-F]+[pP][+-]?[0-9]+[fh]?"
};

// https://www.w3.org/TR/WGSL/#swizzle-names
// SwizzleName: () = {
//     r"[rgba]",
//     r"[rgba][rgba]",
//     r"[rgba][rgba][rgba]",
//     r"[rgba][rgba][rgba][rgba]",
//     r"[xyzw]",
//     r"[xyzw][xyzw]",
//     r"[xyzw][xyzw][xyzw]",
//     r"[xyzw][xyzw][xyzw][xyzw]",
// }

// ----------- below: macros -----------

Comma<T>: () = (T ",")* (T)?;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip line comments
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip block comments
} else {
    _
}
