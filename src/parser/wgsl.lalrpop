use std::cell::RefCell;
use crate::parser::lexer::{self, Token, Span};

grammar(idents: &mut Vec<Span>);

extern {
    type Location = usize;
    type Error = (usize, lexer::Error, usize);
    enum Token {
        // syntactic tokens
        // https://www.w3.org/TR/WGSL/#syntactic-tokens
        "&" => Token::SymAnd,
        "&&" => Token::SymAndAnd,
        "->" => Token::SymArrow,
        "@" => Token::SymAttr,
        "/" => Token::SymForwardSlash,
        "!" => Token::SymBang,
        "[" => Token::SymBracketLeft,
        "]" => Token::SymBracketRight,
        "{" => Token::SymBraceLeft,
        "}" => Token::SymBraceRight,
        ":" => Token::SymColon,
        "," => Token::SymComma,
        "=" => Token::SymEqual,
        "==" => Token::SymEqualEqual,
        "!=" => Token::SymNotEqual,
        ">" => Token::SymGreaterThan,
        ">=" => Token::SymGreaterThanEqual,
        ">>" => Token::SymShiftRight,
        "<" => Token::SymLessThan,
        "<=" => Token::SymLessThanEqual,
        "<<" => Token::SymShiftLeft,
        "%" => Token::SymModulo,
        "-" => Token::SymMinus,
        "--" => Token::SymMinusMinus,
        "." => Token::SymPeriod,
        "+" => Token::SymPlus,
        "++" => Token::SymPlusPlus,
        "|" => Token::SymOr,
        "||" => Token::SymOrOr,
        "(" => Token::SymParenLeft,
        ")" => Token::SymParenRight,
        ";" => Token::SymSemicolon,
        "*" => Token::SymStar,
        "~" => Token::SymTilde,
        "_" => Token::SymUnderscore,
        "^" => Token::SymXor,
        "+=" => Token::SymPlusEqual,
        "-=" => Token::SymMinusEqual,
        "*=" => Token::SymTimesEqual,
        "/=" => Token::SymDivisionEqual,
        "%=" => Token::SymModuloEqual,
        "&=" => Token::SymAndEqual,
        "|=" => Token::SymOrEqual,
        "^=" => Token::SymXorEqual,
        ">>=" => Token::SymShiftRightAssign,
        "<<=" => Token::SymShiftLeftAssign,

        // keywords
        // https://www.w3.org/TR/WGSL/#keyword-summary
        "alias" => Token::KwAlias,
        "break" => Token::KwBreak,
        "case" => Token::KwCase,
        "const" => Token::KwConst,
        "const_assert" => Token::KwConstAssert,
        "continue" => Token::KwContinue,
        "continuing" => Token::KwContinuing,
        "default" => Token::KwDefault,
        "diagnostic" => Token::KwDiagnostic,
        "discard" => Token::KwDiscard,
        "else" => Token::KwElse,
        "enable" => Token::KwEnable,
        "false" => Token::KwFalse,
        "fn" => Token::KwFn,
        "for" => Token::KwFor,
        "if" => Token::KwIf,
        "let" => Token::KwLet,
        "loop" => Token::KwLoop,
        "override" => Token::KwOverride,
        "requires" => Token::KwRequires,
        "return" => Token::KwReturn,
        "struct" => Token::KwStruct,
        "switch" => Token::KwSwitch,
        "true" => Token::KwTrue,
        "var" => Token::KwVar,
        "while" => Token::KwWhile,

        IdentPatternToken => Token::Ident,
        TokNumLit => Token::NumLit,
        TokAttribute => Token::Attribute,
        TokTemplateList => Token::TemplateList,
        TokTemplateArgsStart => Token::TemplateArgsStart,
        TokTemplateArgsEnd => Token::TemplateArgsEnd,
    }
}

// this grammar follows closely the wgsl spec.
// https://www.w3.org/TR/WGSL/#recursive-descent-syntax-global_decl


// 2 wgsl module
// https://www.w3.org/TR/WGSL/#wgsl-module

pub TranslationUnit: () = GlobalDirective * GlobalDecl *;

// custom entrypoint called by the lexer after DisambiguateTemplate is emmited.
// if this one succeeds, the next emitted token by the lexer will be TokTemplateList.
// pub BuildTemplateList: () = TokTemplateStart TemplateArgCommaList TokTemplateEnd => { lexer_ctrl.template_end(); };
pub TryTemplateList: Span = <l:@L> TokTemplateArgsStart TemplateArgCommaList TokTemplateArgsEnd <r:@R> => { (l..r) };


GlobalDecl: () = {
    ";",
    GlobalVariableDecl ";",
    GlobalValueDecl ";",
    TypeAliasDecl ";",
    StructDecl,
    FunctionDecl,
    ConstAssertStatement ";",
};

// context-dependent names
// 3.8 https://www.w3.org/TR/WGSL/#context-dependent-names
// TODO: ensure context dependent names

BuiltinValueName: () = IdentPatternToken;

DiagnosticNameToken: () = IdentPatternToken;

SeverityControlName: () = IdentPatternToken;

EnableExtensionName: () = IdentPatternToken;

SoftwareExtensionName: () = IdentPatternToken;

// 4 directives
// https://www.w3.org/TR/WGSL/#directives
// 3.8.5 https://www.w3.org/TR/WGSL/#extension-names

GlobalDirective: () = {
    DiagnosticDirective,
    EnableDirective,
    RequiresDirective,
};

DiagnosticDirective: () = "diagnostic" DiagnosticControl ";";

EnableDirective: () = "enable" EnableExtensionList ";";

EnableExtensionList: () = EnableExtensionName ( "," EnableExtensionName ) * "," ?;

RequiresDirective: () = "requires" SoftwareExtensionList ";";

SoftwareExtensionList: () = SoftwareExtensionName ( "," SoftwareExtensionName ) * "," ?;

// diagnostic
// 11.6 https://www.w3.org/TR/WGSL/#diagnostic-attr
// 2.3 https://www.w3.org/TR/WGSL/#diagnostics

DiagnosticAttr: () = "@" "diagnostic" DiagnosticControl;

DiagnosticControl: () = "(" SeverityControlName "," DiagnosticRuleName "," ? ")";

DiagnosticRuleName: () = {
    DiagnosticNameToken,
    DiagnosticNameToken "." DiagnosticNameToken,
};

// type
// https://www.w3.org/TR/WGSL/#type-aliases
// https://www.w3.org/TR/WGSL/#type-specifiers

TypeAliasDecl: () = "alias" Ident "=" TypeSpecifier;

TypeSpecifier: () = TemplateElaboratedIdent;

TemplateElaboratedIdent: () = Ident DisambiguateTemplate TemplateList ?;

// struct
// https://www.w3.org/TR/WGSL/#struct-types

StructDecl: () = "struct" Ident StructBodyDecl;

StructBodyDecl: () = "{" StructMember ( "," StructMember ) * "," ? "}";

StructMember: () = Attribute * MemberIdent ":" TypeSpecifier;

// ident
// https://www.w3.org/TR/WGSL/#identifiers
// https://www.w3.org/TR/WGSL/#syntax-ident_pattern_token

Ident: () = <l:@L> IdentPatternToken <r:@R> DisambiguateTemplate => idents.push(l..r);

MemberIdent: () = IdentPatternToken;

// function
// https://www.w3.org/TR/WGSL/#function-declaration-sec

FunctionDecl: () = Attribute * FunctionHeader CompoundStatement;

FunctionHeader: () = "fn" Ident "(" ParamList ? ")" ( "->" Attribute * TemplateElaboratedIdent ) ?;

ParamList: () = Param ( "," Param ) * "," ?;

Param: () = Attribute * Ident ":" TypeSpecifier;

// statement
// https://www.w3.org/TR/WGSL/#statements-summary

Statement: () = {
    ";",
    ReturnStatement ";",
    IfStatement,
    SwitchStatement,
    LoopStatement,
    ForStatement,
    WhileStatement,
    FuncCallStatement ";",
    VariableOrValueStatement ";",
    BreakStatement ";",
    ContinueStatement ";",
    "discard" ";",
    VariableUpdatingStatement ";",
    CompoundStatement,
    ConstAssertStatement ";",
};

VariableUpdatingStatement: () = {
    AssignmentStatement,
    IncrementStatement,
    DecrementStatement,
};

// return statement
// https://www.w3.org/TR/WGSL/#return-statement

ReturnStatement: () = "return" Expression ?;

// if statement
// https://www.w3.org/TR/WGSL/#syntax-if_statement

IfStatement: () = Attribute * IfClause ElseIfClause * ElseClause ?;

IfClause: () = "if" Expression CompoundStatement;

ElseIfClause: () = "else" "if" Expression CompoundStatement;

ElseClause: () = "else" CompoundStatement;

// switch statement
// https://www.w3.org/TR/WGSL/#switch-statement

SwitchStatement: () = Attribute * "switch" Expression SwitchBody;

SwitchBody: () = Attribute * "{" SwitchClause + "}";

SwitchClause: () = {
    CaseClause,
    DefaultAloneClause,
};

CaseClause: () = "case" CaseSelectors ":" ? CompoundStatement;

DefaultAloneClause: () = "default" ":" ? CompoundStatement;

CaseSelectors: () = CaseSelector ( "," CaseSelector ) * "," ?;

CaseSelector: () = {
    "default",
    Expression,
};

// loop statement
// https://www.w3.org/TR/WGSL/#loop-statement

LoopStatement: () = Attribute * "loop" Attribute * "{" Statement * ContinuingStatement ? "}";

// for statement
// https://www.w3.org/TR/WGSL/#syntax-for_statement

ForStatement: () = Attribute * "for" "(" ForHeader ")" CompoundStatement;

ForHeader: () = ForInit ? ";" Expression ? ";" ForUpdate ?;

ForInit: () = {
    VariableOrValueStatement,
    VariableUpdatingStatement,
    FuncCallStatement,
};

ForUpdate: () = {
    VariableUpdatingStatement,
    FuncCallStatement,
};

// while statement
// https://www.w3.org/TR/WGSL/#syntax-while_statement

WhileStatement: () = Attribute * "while" Expression CompoundStatement;

// function call statement
// https://www.w3.org/TR/WGSL/#syntax-func_call_statement

FuncCallStatement: () = CallPhrase;

// variable and value declaration
// https://www.w3.org/TR/WGSL/#var-and-value-decl-grammar

VariableOrValueStatement: () = {
    VariableDecl,
    VariableDecl "=" Expression,
    "let" OptionallyTypedIdent "=" Expression,
    "const" OptionallyTypedIdent "=" Expression,
};

VariableDecl: () = "var" DisambiguateTemplate TemplateList ? OptionallyTypedIdent;

OptionallyTypedIdent: () = Ident ( ":" TypeSpecifier ) ?;

GlobalVariableDecl: () = Attribute * VariableDecl ( "=" Expression ) ?;

GlobalValueDecl: () = {
    "const" OptionallyTypedIdent "=" Expression,
    Attribute * "override" OptionallyTypedIdent ( "=" Expression ) ?,
};

// break statement
// https://www.w3.org/TR/WGSL/#break-statement

BreakStatement: () = "break";

// break-if statement
// https://www.w3.org/TR/WGSL/#break-if-statement

BreakIfStatement: () = "break" "if" Expression ";";

// continue statement
// https://www.w3.org/TR/WGSL/#continue-statement

ContinueStatement: () = "continue";

// continuing statement
// https://www.w3.org/TR/WGSL/#continuing-statement

ContinuingStatement: () = "continuing" ContinuingCompoundStatement;

ContinuingCompoundStatement: () = Attribute * "{" Statement * BreakIfStatement ? "}";

// compound statement
// https://www.w3.org/TR/WGSL/#compound-statement-section

CompoundStatement: () = Attribute * "{" Statement * "}";

// assignment statement
// https://www.w3.org/TR/WGSL/#assignment

AssignmentStatement: () = {
     LhsExpression "=" Expression,
     LhsExpression CompoundAssignmentOperator Expression,
    "_" "=" Expression,
};

CompoundAssignmentOperator: () = {
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "&=",
    "|=",
    "^=",
    ">>=",
    "<<=",
};

// increment decrement statement

IncrementStatement: () = LhsExpression "++";

DecrementStatement: () = LhsExpression "--";

// const_assert statement
// https://www.w3.org/TR/WGSL/#const-assert-statement

ConstAssertStatement: () = "const_assert" Expression;

// expression
// https://www.w3.org/TR/WGSL/#expression-grammar

PrimaryExpression: () = {
    TemplateElaboratedIdent,
    CallExpression,
    Literal,
    ParenExpression,
};

CallExpression: () = CallPhrase;

CallPhrase: () = TemplateElaboratedIdent ArgumentExpressionList;

ParenExpression: () = "(" Expression ")";

ArgumentExpressionList: () = "(" ExpressionCommaList ? ")";

ExpressionCommaList: () = Expression ( "," Expression ) * "," ?;

ComponentOrSwizzleSpecifier: () = {
    "[" Expression "]" ComponentOrSwizzleSpecifier ?,
    "." MemberIdent ComponentOrSwizzleSpecifier ?,
    // "." SwizzleName ComponentOrSwizzleSpecifier ?,
};

UnaryExpression: () = {
    SingularExpression,
    "-" UnaryExpression,
    "!" UnaryExpression,
    "~" UnaryExpression,
    "*" UnaryExpression,
    "&" UnaryExpression,
};

SingularExpression: () = PrimaryExpression ComponentOrSwizzleSpecifier ?;

LhsExpression: () = {
    CoreLhsExpression ComponentOrSwizzleSpecifier ?,
    "*" LhsExpression,
    "&" LhsExpression,
 };
 
CoreLhsExpression: () = {
    Ident DisambiguateTemplate,
    "(" LhsExpression ")",
};

MultiplicativeExpression: () = {
    UnaryExpression,
    MultiplicativeExpression MultiplicativeOperator UnaryExpression,
};

MultiplicativeOperator: () = {
    "*",
    "/",
    "%",
};
 
AdditiveExpression: () = {
    MultiplicativeExpression,
    AdditiveExpression AdditiveOperator MultiplicativeExpression,
};

AdditiveOperator: () = {
    "+",
    "-",
};

ShiftExpression: () = {
    AdditiveExpression,
    UnaryExpression "<<" UnaryExpression,
    UnaryExpression ">>" UnaryExpression,
};

RelationalExpression: () = {
    ShiftExpression,
    ShiftExpression "<" ShiftExpression,
    ShiftExpression ">" ShiftExpression,
    ShiftExpression "<=" ShiftExpression,
    ShiftExpression ">=" ShiftExpression,
    ShiftExpression "==" ShiftExpression,
    ShiftExpression "!=" ShiftExpression,
};

ShortCircuitAndExpression: () = {
    RelationalExpression,
    ShortCircuitAndExpression "&&" RelationalExpression,
 };
 
ShortCircuitOrExpression: () = {
    RelationalExpression,
    ShortCircuitOrExpression "||" RelationalExpression,
 };
 
BinaryOrExpression: () = {
    UnaryExpression,
    BinaryOrExpression "|" UnaryExpression,
};

BinaryAndExpression: () = {
    UnaryExpression,
    BinaryAndExpression "&" UnaryExpression,
};

BinaryXorExpression: () = {
    UnaryExpression,
    BinaryXorExpression "^" UnaryExpression,
};

BitwiseExpression: () = {
    BinaryAndExpression "&" UnaryExpression,
    BinaryOrExpression "|" UnaryExpression,
    BinaryXorExpression "^" UnaryExpression,
};

Expression: () = {
    RelationalExpression,
    ShortCircuitOrExpression "||" RelationalExpression,
    ShortCircuitAndExpression "&&" RelationalExpression,
    BitwiseExpression,
};

// templates
// https://www.w3.org/TR/WGSL/#template-lists-sec

// moved to the top as an entrypoint
// TemplateList: () = TokTemplateArgsStart TemplateArgCommaList TokTemplateArgsEnd;
TemplateList: () = TokTemplateList;

TemplateArgCommaList: () = TemplateArgExpression ( "," TemplateArgExpression ) * "," ?;

TemplateArgExpression: () = Expression;

DisambiguateTemplate: () = => { };

// other

// attribute
// 11 https://www.w3.org/TR/WGSL/#attributes
// TODO incomplete

// Attribute: () =  r"@\w+(?:\s*\([^\)]*\))?";
Attribute: () = TokAttribute;

// literal
// 3.5 https://www.w3.org/TR/WGSL/#literals

Literal: () = {
    "true",
    "false",
    TokNumLit,
    // r"0[iu]?",
    // r"[1-9][0-9]*[iu]?",
    // r"0[xX][0-9a-fA-F]+[iu]?",
    // r"0[fh]",
    // r"[1-9][0-9]*[fh]",
    // r"[0-9]*\.[0-9]+([eE][+-]?[0-9]+)?[fh]?",
    // r"[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?[fh]?",
    // r"[0-9]+[eE][+-]?[0-9]+[fh]?",
    // r"0[xX][0-9a-fA-F]*\.[0-9a-fA-F]+([pP][+-]?[0-9]+[fh]?)?",
    // r"0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*([pP][+-]?[0-9]+[fh]?)?",
    // r"0[xX][0-9a-fA-F]+[pP][+-]?[0-9]+[fh]?"
};

// ----------- below: macros -----------

Comma<T>: () = (T ",")* (T)?;
